{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"x64dbg Automate Home x64dbg Automate is a plugin + client library that adds enhanced scripting and automation capabilities to x64dbg. The heart of this project is the native plugin that externalizes the bridge and scripting interfaces of x64dbg - this is the foundation on which the Python reference client for x64dbg Automate is built. Core Principles First-class Python Support : Bring your own interpreter to automate debug and analysis tasks. Enhanced Features : Automate provides abstractions on top of debugger functionality for easy, concise, and reproducible scripting. Maintained/Modern Plugin and Client : Automate aims to target both the latest x64dbg and Python versions. Clear Documentation : The features of Automate are easy to understand and well documented. Extensible : Build on top of Automate to extend its capabilities even further. Getting Started To get started with x64dbg Automate, it's recommended to visit Installation and Quickstart . \ud83d\udd14 All examples and sample code assume x64dbg is configured to stop on entry and system breakpoints, skipping TLS breakpoints. Source Plugin Repository: https://github.com/dariushoule/x64dbg-automate Python Reference Client Repository: https://github.com/dariushoule/x64dbg-automate-pyclient Contributing I welcome contributions from the community! Please leave issues or suggest features on the GitHub repositories for the project. Support You can reach out to me at darius[at]x64.ooo","title":"Home"},{"location":"#x64dbg-automate-home","text":"x64dbg Automate is a plugin + client library that adds enhanced scripting and automation capabilities to x64dbg. The heart of this project is the native plugin that externalizes the bridge and scripting interfaces of x64dbg - this is the foundation on which the Python reference client for x64dbg Automate is built.","title":"x64dbg Automate Home"},{"location":"#core-principles","text":"First-class Python Support : Bring your own interpreter to automate debug and analysis tasks. Enhanced Features : Automate provides abstractions on top of debugger functionality for easy, concise, and reproducible scripting. Maintained/Modern Plugin and Client : Automate aims to target both the latest x64dbg and Python versions. Clear Documentation : The features of Automate are easy to understand and well documented. Extensible : Build on top of Automate to extend its capabilities even further.","title":"Core Principles"},{"location":"#getting-started","text":"To get started with x64dbg Automate, it's recommended to visit Installation and Quickstart . \ud83d\udd14 All examples and sample code assume x64dbg is configured to stop on entry and system breakpoints, skipping TLS breakpoints.","title":"Getting Started"},{"location":"#source","text":"Plugin Repository: https://github.com/dariushoule/x64dbg-automate Python Reference Client Repository: https://github.com/dariushoule/x64dbg-automate-pyclient","title":"Source"},{"location":"#contributing","text":"I welcome contributions from the community! Please leave issues or suggest features on the GitHub repositories for the project.","title":"Contributing"},{"location":"#support","text":"You can reach out to me at darius[at]x64.ooo","title":"Support"},{"location":"installation/","text":"Installation Step 1: Plugin Download the latest plugin release from https://github.com/dariushoule/x64dbg-automate/releases Extract the contents of the archive into your debugger's plugin directory, creating it as needed. Install directory Bitness x64dbg\\release\\x64\\plugins 64-bit x64dbg\\release\\x32\\plugins 32-bit Step 2: Client Library pip install x64dbg_automate --upgrade Troubleshooting If you receive an error like the following: AssertionError: Incompatible x64dbg plugin and client versions abc != xyz Either your client or plugin is out of date, update them to resolve.","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#step-1-plugin","text":"Download the latest plugin release from https://github.com/dariushoule/x64dbg-automate/releases Extract the contents of the archive into your debugger's plugin directory, creating it as needed. Install directory Bitness x64dbg\\release\\x64\\plugins 64-bit x64dbg\\release\\x32\\plugins 32-bit","title":"Step 1: Plugin"},{"location":"installation/#step-2-client-library","text":"pip install x64dbg_automate --upgrade","title":"Step 2: Client Library"},{"location":"installation/#troubleshooting","text":"If you receive an error like the following: AssertionError: Incompatible x64dbg plugin and client versions abc != xyz Either your client or plugin is out of date, update them to resolve.","title":"Troubleshooting"},{"location":"quickstart/","text":"x64dbg Automate Quickstart An automation session can be launched with four steps: One: Instantiate X64DbgClient and orient it against your installation client = X64DbgClient(x64dbg_path=\"C:\\x64dbg\\release\\x64\\x64dbg.exe\") Two: Start a new debug session or attach to an existing one client.start_session(r'my_cool_program.exe') Three: Act! client.set_breakpoint('GetModuleHandleA') client.go() See Client Reference sections for full capabilities. Four: Clean up client.deattach_session() Example: Hello World \"\"\" Example: Hello x64dbg Automate (64 bit) \"\"\" import sys from x64dbg_automate import X64DbgClient if len(sys.argv) != 2: print(\"Usage: python hello64.py <x64dbg_path>\") quit(1) print('[+] Creating a new x64dbg Automate session') client = X64DbgClient(x64dbg_path=sys.argv[1]) client.start_session(r'c:\\Windows\\system32\\winver.exe') print('[+] Allocating memory in the debugee and writing a string to it') mem = client.virt_alloc() client.write_memory(mem, 'x64dbg Automate Rocks!'.encode('utf-16le')) print('[+] Breakpointing ShellAboutW and running until we hit it') client.set_breakpoint('ShellAboutW', singleshoot=True) client.go() # Entrypoint breakpoint client.wait_until_stopped() client.go() # ShellAboutW client.wait_until_stopped() print('[+] Replacing the ShellAboutW App name with our string') client.set_reg('rdx', mem) client.go() print('[+] Bye bye! Go check out the title bar of the winver window! \ud83e\udd73') client.deattach_session() Output [+] Creating a new x64dbg Automate session [+] Allocating memory in the debugee and writing a string to it [+] Breakpointing ShellAboutW and running until we hit it [+] Replacing the ShellAboutW App name with our string [+] Bye bye! Go check out the title bar of the winver window! \ud83e\udd73 More Examples More examples of x64dbg Automate's capabilities can be seen in: https://github.com/dariushoule/x64dbg-automate-pyclient/tree/main/examples","title":"Quickstart"},{"location":"quickstart/#x64dbg-automate-quickstart","text":"An automation session can be launched with four steps: One: Instantiate X64DbgClient and orient it against your installation client = X64DbgClient(x64dbg_path=\"C:\\x64dbg\\release\\x64\\x64dbg.exe\") Two: Start a new debug session or attach to an existing one client.start_session(r'my_cool_program.exe') Three: Act! client.set_breakpoint('GetModuleHandleA') client.go() See Client Reference sections for full capabilities. Four: Clean up client.deattach_session()","title":"x64dbg Automate Quickstart"},{"location":"quickstart/#example-hello-world","text":"\"\"\" Example: Hello x64dbg Automate (64 bit) \"\"\" import sys from x64dbg_automate import X64DbgClient if len(sys.argv) != 2: print(\"Usage: python hello64.py <x64dbg_path>\") quit(1) print('[+] Creating a new x64dbg Automate session') client = X64DbgClient(x64dbg_path=sys.argv[1]) client.start_session(r'c:\\Windows\\system32\\winver.exe') print('[+] Allocating memory in the debugee and writing a string to it') mem = client.virt_alloc() client.write_memory(mem, 'x64dbg Automate Rocks!'.encode('utf-16le')) print('[+] Breakpointing ShellAboutW and running until we hit it') client.set_breakpoint('ShellAboutW', singleshoot=True) client.go() # Entrypoint breakpoint client.wait_until_stopped() client.go() # ShellAboutW client.wait_until_stopped() print('[+] Replacing the ShellAboutW App name with our string') client.set_reg('rdx', mem) client.go() print('[+] Bye bye! Go check out the title bar of the winver window! \ud83e\udd73') client.deattach_session() Output [+] Creating a new x64dbg Automate session [+] Allocating memory in the debugee and writing a string to it [+] Breakpointing ShellAboutW and running until we hit it [+] Replacing the ShellAboutW App name with our string [+] Bye bye! Go check out the title bar of the winver window! \ud83e\udd73","title":"Example: Hello World"},{"location":"quickstart/#more-examples","text":"More examples of x64dbg Automate's capabilities can be seen in: https://github.com/dariushoule/x64dbg-automate-pyclient/tree/main/examples","title":"More Examples"},{"location":"api/annotations/","text":"Annotations (Labels, Comments, Bookmarks) What is an annotation? Annotations refer to labels, comments, and bookmarks. x64dbg automate supports setting and removing labels / comments, with bookmark support coming soon. API Method Reference set_label_at(address, text) Sets a label at the specified address Parameters: Name Type Description Default address int Address to set the label at required text str Label text required Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def set_label_at(self, address: int, text: str) -> bool: \"\"\" Sets a label at the specified address Args: address: Address to set the label at text: Label text Returns: Success \"\"\" if '\"' in text: raise ValueError(\"Text cannot contain double quotes\") return self.cmd_sync(f'lblset 0x{address:x}, \"{text}\"') del_label_at(address) Deletes a label at the specified address Parameters: Name Type Description Default address int Address to clear the label at required Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def del_label_at(self, address: int) -> bool: \"\"\" Deletes a label at the specified address Args: address: Address to clear the label at Returns: Success \"\"\" return self.cmd_sync(f'lbldel 0x{address:x}') set_comment_at(address, text) Sets a comment at the specified address Parameters: Name Type Description Default address int Address to set the comment at required text str comment text required Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def set_comment_at(self, address: int, text: str) -> bool: \"\"\" Sets a comment at the specified address Args: address: Address to set the comment at text: comment text Returns: Success \"\"\" if '\"' in text: raise ValueError(\"Text cannot contain double quotes\") return self.cmd_sync(f'cmtset 0x{address:x}, \"{text}\"') del_comment_at(address) Deletes a comment at the specified address Parameters: Name Type Description Default address int Address to clear the comment at required Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def del_comment_at(self, address: int) -> bool: \"\"\" Deletes a comment at the specified address Args: address: Address to clear the comment at Returns: Success \"\"\" return self.cmd_sync(f'cmtdel 0x{address:x}') get_label_at(addr, segment_reg=SegmentReg.SegDefault) Retrieves the label at the specified address Parameters: Name Type Description Default addr int The address to get the label for required segment_reg SegmentReg The segment register to use SegDefault Returns: Type Description str The label or an empty string if no label was found Source code in x64dbg_automate\\commands_xauto.py def get_label_at(self, addr: int, segment_reg: SegmentReg = SegmentReg.SegDefault) -> str: \"\"\" Retrieves the label at the specified address Args: addr: The address to get the label for segment_reg: The segment register to use Returns: The label or an empty string if no label was found \"\"\" res, label = self._send_request(XAutoCommand.XAUTO_REQ_GET_LABEL, addr, segment_reg) if not res: return \"\" return label get_comment_at(addr) Retrieves the comment at the specified address Parameters: Name Type Description Default addr int The address to get the comment for required Returns: Type Description str The label or an empty string if no comment was found Source code in x64dbg_automate\\commands_xauto.py def get_comment_at(self, addr: int) -> str: \"\"\" Retrieves the comment at the specified address Args: addr: The address to get the comment for Returns: The label or an empty string if no comment was found \"\"\" res, comment = self._send_request(XAutoCommand.XAUTO_REQ_GET_COMMENT, addr) if not res: return \"\" return comment","title":"Labels, Comments, Bookmarks"},{"location":"api/annotations/#annotations-labels-comments-bookmarks","text":"","title":"Annotations (Labels, Comments, Bookmarks)"},{"location":"api/annotations/#what-is-an-annotation","text":"Annotations refer to labels, comments, and bookmarks. x64dbg automate supports setting and removing labels / comments, with bookmark support coming soon.","title":"What is an annotation?"},{"location":"api/annotations/#api-method-reference","text":"","title":"API Method Reference"},{"location":"api/annotations/#x64dbg_automate.X64DbgClient.set_label_at","text":"Sets a label at the specified address Parameters: Name Type Description Default address int Address to set the label at required text str Label text required Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def set_label_at(self, address: int, text: str) -> bool: \"\"\" Sets a label at the specified address Args: address: Address to set the label at text: Label text Returns: Success \"\"\" if '\"' in text: raise ValueError(\"Text cannot contain double quotes\") return self.cmd_sync(f'lblset 0x{address:x}, \"{text}\"')","title":"set_label_at"},{"location":"api/annotations/#x64dbg_automate.X64DbgClient.del_label_at","text":"Deletes a label at the specified address Parameters: Name Type Description Default address int Address to clear the label at required Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def del_label_at(self, address: int) -> bool: \"\"\" Deletes a label at the specified address Args: address: Address to clear the label at Returns: Success \"\"\" return self.cmd_sync(f'lbldel 0x{address:x}')","title":"del_label_at"},{"location":"api/annotations/#x64dbg_automate.X64DbgClient.set_comment_at","text":"Sets a comment at the specified address Parameters: Name Type Description Default address int Address to set the comment at required text str comment text required Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def set_comment_at(self, address: int, text: str) -> bool: \"\"\" Sets a comment at the specified address Args: address: Address to set the comment at text: comment text Returns: Success \"\"\" if '\"' in text: raise ValueError(\"Text cannot contain double quotes\") return self.cmd_sync(f'cmtset 0x{address:x}, \"{text}\"')","title":"set_comment_at"},{"location":"api/annotations/#x64dbg_automate.X64DbgClient.del_comment_at","text":"Deletes a comment at the specified address Parameters: Name Type Description Default address int Address to clear the comment at required Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def del_comment_at(self, address: int) -> bool: \"\"\" Deletes a comment at the specified address Args: address: Address to clear the comment at Returns: Success \"\"\" return self.cmd_sync(f'cmtdel 0x{address:x}')","title":"del_comment_at"},{"location":"api/annotations/#x64dbg_automate.X64DbgClient.get_label_at","text":"Retrieves the label at the specified address Parameters: Name Type Description Default addr int The address to get the label for required segment_reg SegmentReg The segment register to use SegDefault Returns: Type Description str The label or an empty string if no label was found Source code in x64dbg_automate\\commands_xauto.py def get_label_at(self, addr: int, segment_reg: SegmentReg = SegmentReg.SegDefault) -> str: \"\"\" Retrieves the label at the specified address Args: addr: The address to get the label for segment_reg: The segment register to use Returns: The label or an empty string if no label was found \"\"\" res, label = self._send_request(XAutoCommand.XAUTO_REQ_GET_LABEL, addr, segment_reg) if not res: return \"\" return label","title":"get_label_at"},{"location":"api/annotations/#x64dbg_automate.X64DbgClient.get_comment_at","text":"Retrieves the comment at the specified address Parameters: Name Type Description Default addr int The address to get the comment for required Returns: Type Description str The label or an empty string if no comment was found Source code in x64dbg_automate\\commands_xauto.py def get_comment_at(self, addr: int) -> str: \"\"\" Retrieves the comment at the specified address Args: addr: The address to get the comment for Returns: The label or an empty string if no comment was found \"\"\" res, comment = self._send_request(XAutoCommand.XAUTO_REQ_GET_COMMENT, addr) if not res: return \"\" return comment","title":"get_comment_at"},{"location":"api/assembler-disassembler/","text":"Assembling and Disassembling The Assembler and Disassembler features of x64dbg are supported in Automate. Symbols and expressions are supported in the assembler as they are in the UI. Example: Assemble and Disassemble \"\"\" Example: Assemble and Disassemble (64 bit) \"\"\" import sys from x64dbg_automate import X64DbgClient if len(sys.argv) != 2: print(\"Usage: python hello64.py <x64dbg_path>\") quit(1) print('[+] Creating a new x64dbg Automate session') client = X64DbgClient(x64dbg_path=sys.argv[1]) client.start_session(r'c:\\Windows\\system32\\winver.exe') print('[+] Getting the value of RIP') rip = client.get_reg('rip') print(f'\\tRIP: 0x{rip:X}') print('[+] Assembling instructions') k32_base, _ = client.eval_sync('kernel32') client.set_label_at(k32_base, 'my_cool_label') i = rip i = i + client.assemble_at(i, 'mov rax, OutputDebugStringA') # Symbol i = i + client.assemble_at(i, 'mov rdx, 0x401000') # Constant i = i + client.assemble_at(i, 'mov rcx, my_cool_label') # Label i = i + client.assemble_at(i, 'lea rcx, [rcx * 2 + 4]') # Scale i = i + client.assemble_at(i, 'mov rbx, gs:[0]') # Segmentation i = i + client.assemble_at(i, f'mov rdi, 0x{client.virt_alloc():x}') # Interpolation print('[+] Disassembling instructions') i = rip for _ in range(6): ins = client.disassemble_at(i) print(f'\\t{i:016X}: {ins.instruction}') i = i + ins.instr_size print('[+] Cleaning up') client.terminate_session() [+] Creating a new x64dbg Automate session [+] Getting the value of RIP RIP: 0x7FF962D4C135 [+] Assembling instructions [+] Disassembling instructions 00007FF962D4C135: mov rax, 0x7FF961A698C0 00007FF962D4C13F: mov rdx, 0x401000 00007FF962D4C146: mov rcx, 0x7FF961A50000 00007FF962D4C150: lea rcx, ds:[rcx*2+0x04] 00007FF962D4C158: mov rbx, qword ptr gs:[0x0000000000000000] 00007FF962D4C161: mov rdi, 0x21CBEDC0000 [+] Cleaning up API Method Reference assemble_at(addr, instr) Assembles a single instruction at the specified address Parameters: Name Type Description Default addr int Address to assemble at required instr str Instruction to assemble required Returns: Type Description int | None The size of the assembled instruction, or None on failure Source code in x64dbg_automate\\hla_xauto.py def assemble_at(self, addr: int, instr: str) -> int | None: \"\"\" Assembles a single instruction at the specified address Args: addr: Address to assemble at instr: Instruction to assemble Returns: The size of the assembled instruction, or None on failure \"\"\" res = self._assemble_at(addr, instr) if not res: return None ins = self.disassemble_at(addr) if not ins: return None return ins.instr_size disassemble_at(addr) Disassembles a single instruction at the specified address Parameters: Name Type Description Default addr int The address to disassemble at required Returns: Type Description Instruction | None An Instruction object or None if the disassembly failed Source code in x64dbg_automate\\commands_xauto.py def disassemble_at(self, addr: int) -> Instruction | None: \"\"\" Disassembles a single instruction at the specified address Args: addr: The address to disassemble at Returns: An Instruction object or None if the disassembly failed \"\"\" res = self._send_request(XAutoCommand.XAUTO_REQ_DISASSEMBLE, addr) if not res: return None return Instruction( instruction=res[0], argcount=res[1], instr_size=res[2], type=DisasmInstrType(res[3]), arg=[InstructionArg( mnemonic=arg[0], type=DisasmArgType(arg[1]), segment=SegmentReg(arg[2]), constant=arg[3], value=arg[4], memvalue=arg[5], ) for arg in res[4]] ) API Model Reference Instruction Source code in x64dbg_automate\\models.py class Instruction(BaseModel): instruction: str argcount: int instr_size: int type: DisasmInstrType arg: list[InstructionArg] DisasmInstrType Source code in x64dbg_automate\\models.py class DisasmInstrType(IntEnum): Normal = 0 Branch = 1 Stack = 2 DisasmArgType Source code in x64dbg_automate\\models.py class DisasmArgType(IntEnum): Normal = 0 Memory = 1 InstructionArg Source code in x64dbg_automate\\models.py class InstructionArg(BaseModel): mnemonic: str type: DisasmArgType segment: SegmentReg constant: int value: int memvalue: int SegmentReg Source code in x64dbg_automate\\models.py class SegmentReg(IntEnum): SegDefault = 0 SegEs = 1 SegDs = 2 SegFs = 3 SegGs = 4 SegCs = 5 SegSs = 6","title":"Assembling and Disassembling"},{"location":"api/assembler-disassembler/#assembling-and-disassembling","text":"The Assembler and Disassembler features of x64dbg are supported in Automate. Symbols and expressions are supported in the assembler as they are in the UI.","title":"Assembling and Disassembling"},{"location":"api/assembler-disassembler/#example-assemble-and-disassemble","text":"\"\"\" Example: Assemble and Disassemble (64 bit) \"\"\" import sys from x64dbg_automate import X64DbgClient if len(sys.argv) != 2: print(\"Usage: python hello64.py <x64dbg_path>\") quit(1) print('[+] Creating a new x64dbg Automate session') client = X64DbgClient(x64dbg_path=sys.argv[1]) client.start_session(r'c:\\Windows\\system32\\winver.exe') print('[+] Getting the value of RIP') rip = client.get_reg('rip') print(f'\\tRIP: 0x{rip:X}') print('[+] Assembling instructions') k32_base, _ = client.eval_sync('kernel32') client.set_label_at(k32_base, 'my_cool_label') i = rip i = i + client.assemble_at(i, 'mov rax, OutputDebugStringA') # Symbol i = i + client.assemble_at(i, 'mov rdx, 0x401000') # Constant i = i + client.assemble_at(i, 'mov rcx, my_cool_label') # Label i = i + client.assemble_at(i, 'lea rcx, [rcx * 2 + 4]') # Scale i = i + client.assemble_at(i, 'mov rbx, gs:[0]') # Segmentation i = i + client.assemble_at(i, f'mov rdi, 0x{client.virt_alloc():x}') # Interpolation print('[+] Disassembling instructions') i = rip for _ in range(6): ins = client.disassemble_at(i) print(f'\\t{i:016X}: {ins.instruction}') i = i + ins.instr_size print('[+] Cleaning up') client.terminate_session() [+] Creating a new x64dbg Automate session [+] Getting the value of RIP RIP: 0x7FF962D4C135 [+] Assembling instructions [+] Disassembling instructions 00007FF962D4C135: mov rax, 0x7FF961A698C0 00007FF962D4C13F: mov rdx, 0x401000 00007FF962D4C146: mov rcx, 0x7FF961A50000 00007FF962D4C150: lea rcx, ds:[rcx*2+0x04] 00007FF962D4C158: mov rbx, qword ptr gs:[0x0000000000000000] 00007FF962D4C161: mov rdi, 0x21CBEDC0000 [+] Cleaning up","title":"Example: Assemble and Disassemble"},{"location":"api/assembler-disassembler/#api-method-reference","text":"","title":"API Method Reference"},{"location":"api/assembler-disassembler/#x64dbg_automate.X64DbgClient.assemble_at","text":"Assembles a single instruction at the specified address Parameters: Name Type Description Default addr int Address to assemble at required instr str Instruction to assemble required Returns: Type Description int | None The size of the assembled instruction, or None on failure Source code in x64dbg_automate\\hla_xauto.py def assemble_at(self, addr: int, instr: str) -> int | None: \"\"\" Assembles a single instruction at the specified address Args: addr: Address to assemble at instr: Instruction to assemble Returns: The size of the assembled instruction, or None on failure \"\"\" res = self._assemble_at(addr, instr) if not res: return None ins = self.disassemble_at(addr) if not ins: return None return ins.instr_size","title":"assemble_at"},{"location":"api/assembler-disassembler/#x64dbg_automate.X64DbgClient.disassemble_at","text":"Disassembles a single instruction at the specified address Parameters: Name Type Description Default addr int The address to disassemble at required Returns: Type Description Instruction | None An Instruction object or None if the disassembly failed Source code in x64dbg_automate\\commands_xauto.py def disassemble_at(self, addr: int) -> Instruction | None: \"\"\" Disassembles a single instruction at the specified address Args: addr: The address to disassemble at Returns: An Instruction object or None if the disassembly failed \"\"\" res = self._send_request(XAutoCommand.XAUTO_REQ_DISASSEMBLE, addr) if not res: return None return Instruction( instruction=res[0], argcount=res[1], instr_size=res[2], type=DisasmInstrType(res[3]), arg=[InstructionArg( mnemonic=arg[0], type=DisasmArgType(arg[1]), segment=SegmentReg(arg[2]), constant=arg[3], value=arg[4], memvalue=arg[5], ) for arg in res[4]] )","title":"disassemble_at"},{"location":"api/assembler-disassembler/#api-model-reference","text":"","title":"API Model Reference"},{"location":"api/assembler-disassembler/#x64dbg_automate.models.Instruction","text":"Source code in x64dbg_automate\\models.py class Instruction(BaseModel): instruction: str argcount: int instr_size: int type: DisasmInstrType arg: list[InstructionArg]","title":"Instruction"},{"location":"api/assembler-disassembler/#x64dbg_automate.models.DisasmInstrType","text":"Source code in x64dbg_automate\\models.py class DisasmInstrType(IntEnum): Normal = 0 Branch = 1 Stack = 2","title":"DisasmInstrType"},{"location":"api/assembler-disassembler/#x64dbg_automate.models.DisasmArgType","text":"Source code in x64dbg_automate\\models.py class DisasmArgType(IntEnum): Normal = 0 Memory = 1","title":"DisasmArgType"},{"location":"api/assembler-disassembler/#x64dbg_automate.models.InstructionArg","text":"Source code in x64dbg_automate\\models.py class InstructionArg(BaseModel): mnemonic: str type: DisasmArgType segment: SegmentReg constant: int value: int memvalue: int","title":"InstructionArg"},{"location":"api/assembler-disassembler/#x64dbg_automate.models.SegmentReg","text":"Source code in x64dbg_automate\\models.py class SegmentReg(IntEnum): SegDefault = 0 SegEs = 1 SegDs = 2 SegFs = 3 SegGs = 4 SegCs = 5 SegSs = 6","title":"SegmentReg"},{"location":"api/breakpoints/","text":"Breakpoints Management of breakpoints are supported nearly completely by x64dbg Automate. Software, hardware, and memory breakpoints are usable, but their condition and log components are not yet exposed. Example: Breakpoints \"\"\" Example: Breakpoints (64 bit) \"\"\" \"\"\" Example: Breakpoints (64 bit) \"\"\" import sys from x64dbg_automate import X64DbgClient from x64dbg_automate.events import EventType if len(sys.argv) != 2: print(\"Usage: python sessions.py <x64dbg_path>\") quit(1) print('[+] Creating the x64dbg Automate session') client = X64DbgClient(x64dbg_path=sys.argv[1]) client.start_session(r'c:\\Windows\\system32\\winver.exe') print('[+] Writing shellcode to demonstrate breakpoint features') sys_entry, _ = client.eval_sync('rip') i = sys_entry i = i + client.assemble_at(i, 'mov rax, GetCurrentProcessId') i = i + client.assemble_at(i, 'call rax') print('[+] Setting a standard breakpoint at GetCurrentProcessId') client.set_breakpoint('GetCurrentProcessId', singleshoot=True) client.go() print('[+] Waiting until the debugee is stopped at the software breakpoint') bp = client.wait_for_debug_event(EventType.EVENT_BREAKPOINT) client.clear_debug_events() print(f'[+] Breakpoint \"{bp.event_data.name}\" hit at {bp.event_data.addr:X} with singleshoot={bp.event_data.singleshoot}') print('[+] Resetting and setting a hardware breakpoint at GetCurrentProcessId') client.set_reg('rip', sys_entry) client.set_hardware_breakpoint('GetCurrentProcessId') client.go() print('[+] Waiting until the debugee is stopped at the hardware breakpoint') client.wait_for_debug_event(EventType.EVENT_BREAKPOINT) client.clear_debug_events() print('[+] Clearing hardware breakpoint') client.clear_hardware_breakpoint('GetCurrentProcessId') print('[+] Resetting and setting a memory breakpoint at GetCurrentProcessId') client.set_reg('rip', sys_entry) client.set_memory_breakpoint('GetCurrentProcessId', restore=False) client.go() print('[+] Waiting until the debugee is stopped at the memory breakpoint') client.wait_for_debug_event(EventType.EVENT_BREAKPOINT) client.clear_debug_events() print('[+] Cleaning up') client.terminate_session() [+] Creating the x64dbg Automate session [+] Writing shellcode to demonstrate breakpoint features [+] Setting a standard breakpoint at GetCurrentProcessId [+] Waiting until the debugee is stopped at the software breakpoint [+] Breakpoint \"bpx_GetCurrentProcessId\" hit at 7FFC973A36E0 with singleshoot=True [+] Resetting and setting a hardware breakpoint at GetCurrentProcessId [+] Waiting until the debugee is stopped at the hardware breakpoint [+] Clearing hardware breakpoint [+] Resetting and setting a memory breakpoint at GetCurrentProcessId [+] Waiting until the debugee is stopped at the memory breakpoint [+] Cleaning up API Method Reference get_breakpoints(bp_type) Retrieves all breakpoints of the specified type Parameters: Name Type Description Default bp_type BreakpointType The type of breakpoint to get required Returns: Type Description list [ Breakpoint ] A list of Breakpoint objects Source code in x64dbg_automate\\commands_xauto.py def get_breakpoints(self, bp_type: BreakpointType) -> list[Breakpoint]: \"\"\" Retrieves all breakpoints of the specified type Args: bp_type: The type of breakpoint to get Returns: A list of Breakpoint objects \"\"\" resp = self._send_request(XAutoCommand.XAUTO_REQ_GET_BREAKPOINTS, bp_type) return [Breakpoint( type=BreakpointType(bp[0]), addr=bp[1], enabled=bp[2], singleshoot=bp[3], active=bp[4], name=bp[5], mod=bp[6], slot=bp[7], typeEx=bp[8], hwSize=bp[9], hitCount=bp[10], fastResume=bp[11], silent=bp[12], breakCondition=bp[13], logText=bp[14], logCondition=bp[15], commandText=bp[16], commandCondition=bp[17] ) for bp in resp] set_breakpoint(address_or_symbol, name=None, bp_type=StandardBreakpointType.Short, singleshoot=False) Sets a software breakpoint at the specified address or symbol. Parameters: Name Type Description Default address_or_symbol int | str Address or symbol to set the breakpoint at required name str | None Optional name for the breakpoint None bp_type StandardBreakpointType Type of software breakpoint to set Short singleshoot bool Set a single-shot breakpoint False Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def set_breakpoint(self, address_or_symbol: int | str, name: str | None = None, bp_type: StandardBreakpointType = StandardBreakpointType.Short, singleshoot: bool = False) -> bool: \"\"\" Sets a software breakpoint at the specified address or symbol. Args: address_or_symbol: Address or symbol to set the breakpoint at name: Optional name for the breakpoint bp_type: Type of software breakpoint to set singleshoot: Set a single-shot breakpoint Returns: Success \"\"\" bp_type_str = str(bp_type).lower() if singleshoot and bp_type_str != \"ss\": bp_type_str = f'ss{bp_type_str}' if isinstance(address_or_symbol, int): name = name or f\"bpx_{address_or_symbol:x}\" return self.cmd_sync(f'bpx 0x{address_or_symbol:x}, \"{name}\", {bp_type_str}') else: name = name or f\"bpx_{address_or_symbol.replace(' ', '_')}\" if '\"' in name: raise ValueError(\"Name cannot contain double quotes\") return self.cmd_sync(f'bpx {address_or_symbol}, \"{name}\", {bp_type_str}') set_hardware_breakpoint(address_or_symbol, bp_type=HardwareBreakpointType.x, size=1) Sets a hardware breakpoint at the specified address or symbol. Parameters: Name Type Description Default address_or_symbol int | str Address or symbol to set the breakpoint at required bp_type HardwareBreakpointType Type of software breakpoint to set x size int breakpoint size, one of [1, 2, 4, 8] 1 Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def set_hardware_breakpoint(self, address_or_symbol: int | str, bp_type: HardwareBreakpointType = HardwareBreakpointType.x, size: int = 1) -> bool: \"\"\" Sets a hardware breakpoint at the specified address or symbol. Args: address_or_symbol: Address or symbol to set the breakpoint at bp_type: Type of software breakpoint to set size: breakpoint size, one of [1, 2, 4, 8] Returns: Success \"\"\" if size not in [1, 2, 4, 8]: raise ValueError(\"Invalid size\") if isinstance(address_or_symbol, int): return self.cmd_sync(f'bph 0x{address_or_symbol:x}, {bp_type}, {size}') else: return self.cmd_sync(f'bph {address_or_symbol}, {bp_type}, {size}') set_memory_breakpoint(address_or_symbol, bp_type=MemoryBreakpointType.a, restore=True) Sets a memory breakpoint at the specified address or symbol. Parameters: Name Type Description Default address_or_symbol int | str Address or symbol to set the breakpoint at required bp_type MemoryBreakpointType Type of software breakpoint to set a restore bool Restore the original memory protection True Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def set_memory_breakpoint(self, address_or_symbol: int | str, bp_type: MemoryBreakpointType = MemoryBreakpointType.a, restore: bool = True) -> bool: \"\"\" Sets a memory breakpoint at the specified address or symbol. Args: address_or_symbol: Address or symbol to set the breakpoint at bp_type: Type of software breakpoint to set restore: Restore the original memory protection Returns: Success \"\"\" if isinstance(address_or_symbol, int): return self.cmd_sync(f'bpm 0x{address_or_symbol:x}, {int(restore)}, {bp_type}') else: return self.cmd_sync(f'bpm {address_or_symbol}, {int(restore)}, {bp_type}') clear_breakpoint(address_name_symbol_or_none=None) Clears software breakpoint at the specified address, name, or symbol. Parameters: Name Type Description Default address_name_symbol_or_none int | str | None Address or symbol to remove the breakpoint at (None removes all breakpoints of this type) None Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def clear_breakpoint(self, address_name_symbol_or_none: int | str | None = None) -> bool: \"\"\" Clears software breakpoint at the specified address, name, or symbol. Args: address_name_symbol_or_none: Address or symbol to remove the breakpoint at (None removes all breakpoints of this type) Returns: Success \"\"\" if address_name_symbol_or_none is None: return self.cmd_sync('bpc') if isinstance(address_name_symbol_or_none, int): return self.cmd_sync(f'bpc 0x{address_name_symbol_or_none:x}') return self.cmd_sync(f'bpc \"{address_name_symbol_or_none}\"') clear_hardware_breakpoint(address_symbol_or_none=None) Clears hardware breakpoint at the specified address or symbol. Parameters: Name Type Description Default address_symbol_or_none int | str | None Address or symbol to remove the breakpoint at (None removes all breakpoints of this type) None Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def clear_hardware_breakpoint(self, address_symbol_or_none: int | str | None = None) -> bool: \"\"\" Clears hardware breakpoint at the specified address or symbol. Args: address_symbol_or_none: Address or symbol to remove the breakpoint at (None removes all breakpoints of this type) Returns: Success \"\"\" if address_symbol_or_none is None: return self.cmd_sync('bphc') if isinstance(address_symbol_or_none, int): return self.cmd_sync(f'bphc 0x{address_symbol_or_none:x}') return self.cmd_sync(f'bphc {address_symbol_or_none}') clear_memory_breakpoint(address_symbol_or_none=None) Clears memory breakpoint at the specified address or symbol. Parameters: Name Type Description Default address_symbol_or_none int | str | None Address or symbol to remove the breakpoint at (None removes all breakpoints of this type) None Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def clear_memory_breakpoint(self, address_symbol_or_none: int | str | None = None) -> bool: \"\"\" Clears memory breakpoint at the specified address or symbol. Args: address_symbol_or_none: Address or symbol to remove the breakpoint at (None removes all breakpoints of this type) Returns: Success \"\"\" if address_symbol_or_none is None: return self.cmd_sync('bpmc') if isinstance(address_symbol_or_none, int): return self.cmd_sync(f'bpmc 0x{address_symbol_or_none:x}') return self.cmd_sync(f'bpmc {address_symbol_or_none}') toggle_breakpoint(address_name_symbol_or_none=None, on=True) Toggles software breakpoint at the specified address or symbol. Parameters: Name Type Description Default address_name_symbol_or_none int | str | None Address, name, or symbol to toggle the breakpoint at None on bool Enable or disable the breakpoint True Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def toggle_breakpoint(self, address_name_symbol_or_none: int | str | None = None, on: bool = True) -> bool: \"\"\" Toggles software breakpoint at the specified address or symbol. Args: address_name_symbol_or_none: Address, name, or symbol to toggle the breakpoint at on: Enable or disable the breakpoint Returns: Success \"\"\" toggle_cmd = 'bpe' if on else 'bpd' if isinstance(address_name_symbol_or_none, int): return self.cmd_sync(f'{toggle_cmd} 0x{address_name_symbol_or_none:x}') elif address_name_symbol_or_none is None: return self.cmd_sync(f'{toggle_cmd}') else: return self.cmd_sync(f'{toggle_cmd} {address_name_symbol_or_none}') toggle_hardware_breakpoint(address_symbol_or_none=None, on=True) Toggles hardware breakpoint at the specified address or symbol. Parameters: Name Type Description Default address_symbol_or_none int | str | None Address or symbol to toggle the breakpoint at None on bool Enable or disable the breakpoint True Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def toggle_hardware_breakpoint(self, address_symbol_or_none: int | str | None = None, on: bool = True) -> bool: \"\"\" Toggles hardware breakpoint at the specified address or symbol. Args: address_symbol_or_none: Address or symbol to toggle the breakpoint at on: Enable or disable the breakpoint Returns: Success \"\"\" toggle_cmd = 'bphe' if on else 'bphd' if isinstance(address_symbol_or_none, int): return self.cmd_sync(f'{toggle_cmd} 0x{address_symbol_or_none:x}') elif address_symbol_or_none is None: return self.cmd_sync(f'{toggle_cmd}') else: return self.cmd_sync(f'{toggle_cmd} {address_symbol_or_none}') toggle_memory_breakpoint(address_symbol_or_none=None, on=True) Toggles memory breakpoint at the specified address or symbol. Parameters: Name Type Description Default address_symbol_or_none int | str | None Address or symbol to toggle the breakpoint at None on bool Enable or disable the breakpoint True Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def toggle_memory_breakpoint(self, address_symbol_or_none: int | str | None = None, on: bool = True) -> bool: \"\"\" Toggles memory breakpoint at the specified address or symbol. Args: address_symbol_or_none: Address or symbol to toggle the breakpoint at on: Enable or disable the breakpoint Returns: Success \"\"\" toggle_cmd = 'bpme' if on else 'bpmd' if isinstance(address_symbol_or_none, int): return self.cmd_sync(f'{toggle_cmd} 0x{address_symbol_or_none:x}') elif address_symbol_or_none is None: return self.cmd_sync(f'{toggle_cmd}') else: return self.cmd_sync(f'{toggle_cmd} {address_symbol_or_none}') API Model Reference Breakpoint Source code in x64dbg_automate\\models.py class Breakpoint(BaseModel): type: BreakpointType addr: int enabled: bool singleshoot: bool active: bool name: str mod: str slot: int typeEx: int hwSize: int hitCount: int fastResume: bool silent: bool breakCondition: str logText: str logCondition: str commandText: str commandCondition: str BreakpointType Source code in x64dbg_automate\\models.py class BreakpointType(IntEnum): BpNone = 0, BpNormal = 1, BpHardware = 2, BpMemory = 4, BpDll = 8, BpException = 16 StandardBreakpointType Source code in x64dbg_automate\\models.py class StandardBreakpointType(StrEnum): SingleShotInt3 = 'ss' # CC (SingleShoot) Long = 'long' # CD03 Ud2 = 'ud2' # 0F0B Short = 'short' # CC HardwareBreakpointType Source code in x64dbg_automate\\models.py class HardwareBreakpointType(StrEnum): r = 'r' w = 'w' x = 'x' MemoryBreakpointType Source code in x64dbg_automate\\models.py class MemoryBreakpointType(StrEnum): r = 'r' w = 'w' x = 'x' a = 'a'","title":"Breakpoints"},{"location":"api/breakpoints/#breakpoints","text":"Management of breakpoints are supported nearly completely by x64dbg Automate. Software, hardware, and memory breakpoints are usable, but their condition and log components are not yet exposed.","title":"Breakpoints"},{"location":"api/breakpoints/#example-breakpoints","text":"\"\"\" Example: Breakpoints (64 bit) \"\"\" \"\"\" Example: Breakpoints (64 bit) \"\"\" import sys from x64dbg_automate import X64DbgClient from x64dbg_automate.events import EventType if len(sys.argv) != 2: print(\"Usage: python sessions.py <x64dbg_path>\") quit(1) print('[+] Creating the x64dbg Automate session') client = X64DbgClient(x64dbg_path=sys.argv[1]) client.start_session(r'c:\\Windows\\system32\\winver.exe') print('[+] Writing shellcode to demonstrate breakpoint features') sys_entry, _ = client.eval_sync('rip') i = sys_entry i = i + client.assemble_at(i, 'mov rax, GetCurrentProcessId') i = i + client.assemble_at(i, 'call rax') print('[+] Setting a standard breakpoint at GetCurrentProcessId') client.set_breakpoint('GetCurrentProcessId', singleshoot=True) client.go() print('[+] Waiting until the debugee is stopped at the software breakpoint') bp = client.wait_for_debug_event(EventType.EVENT_BREAKPOINT) client.clear_debug_events() print(f'[+] Breakpoint \"{bp.event_data.name}\" hit at {bp.event_data.addr:X} with singleshoot={bp.event_data.singleshoot}') print('[+] Resetting and setting a hardware breakpoint at GetCurrentProcessId') client.set_reg('rip', sys_entry) client.set_hardware_breakpoint('GetCurrentProcessId') client.go() print('[+] Waiting until the debugee is stopped at the hardware breakpoint') client.wait_for_debug_event(EventType.EVENT_BREAKPOINT) client.clear_debug_events() print('[+] Clearing hardware breakpoint') client.clear_hardware_breakpoint('GetCurrentProcessId') print('[+] Resetting and setting a memory breakpoint at GetCurrentProcessId') client.set_reg('rip', sys_entry) client.set_memory_breakpoint('GetCurrentProcessId', restore=False) client.go() print('[+] Waiting until the debugee is stopped at the memory breakpoint') client.wait_for_debug_event(EventType.EVENT_BREAKPOINT) client.clear_debug_events() print('[+] Cleaning up') client.terminate_session() [+] Creating the x64dbg Automate session [+] Writing shellcode to demonstrate breakpoint features [+] Setting a standard breakpoint at GetCurrentProcessId [+] Waiting until the debugee is stopped at the software breakpoint [+] Breakpoint \"bpx_GetCurrentProcessId\" hit at 7FFC973A36E0 with singleshoot=True [+] Resetting and setting a hardware breakpoint at GetCurrentProcessId [+] Waiting until the debugee is stopped at the hardware breakpoint [+] Clearing hardware breakpoint [+] Resetting and setting a memory breakpoint at GetCurrentProcessId [+] Waiting until the debugee is stopped at the memory breakpoint [+] Cleaning up","title":"Example: Breakpoints"},{"location":"api/breakpoints/#api-method-reference","text":"","title":"API Method Reference"},{"location":"api/breakpoints/#x64dbg_automate.X64DbgClient.get_breakpoints","text":"Retrieves all breakpoints of the specified type Parameters: Name Type Description Default bp_type BreakpointType The type of breakpoint to get required Returns: Type Description list [ Breakpoint ] A list of Breakpoint objects Source code in x64dbg_automate\\commands_xauto.py def get_breakpoints(self, bp_type: BreakpointType) -> list[Breakpoint]: \"\"\" Retrieves all breakpoints of the specified type Args: bp_type: The type of breakpoint to get Returns: A list of Breakpoint objects \"\"\" resp = self._send_request(XAutoCommand.XAUTO_REQ_GET_BREAKPOINTS, bp_type) return [Breakpoint( type=BreakpointType(bp[0]), addr=bp[1], enabled=bp[2], singleshoot=bp[3], active=bp[4], name=bp[5], mod=bp[6], slot=bp[7], typeEx=bp[8], hwSize=bp[9], hitCount=bp[10], fastResume=bp[11], silent=bp[12], breakCondition=bp[13], logText=bp[14], logCondition=bp[15], commandText=bp[16], commandCondition=bp[17] ) for bp in resp]","title":"get_breakpoints"},{"location":"api/breakpoints/#x64dbg_automate.X64DbgClient.set_breakpoint","text":"Sets a software breakpoint at the specified address or symbol. Parameters: Name Type Description Default address_or_symbol int | str Address or symbol to set the breakpoint at required name str | None Optional name for the breakpoint None bp_type StandardBreakpointType Type of software breakpoint to set Short singleshoot bool Set a single-shot breakpoint False Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def set_breakpoint(self, address_or_symbol: int | str, name: str | None = None, bp_type: StandardBreakpointType = StandardBreakpointType.Short, singleshoot: bool = False) -> bool: \"\"\" Sets a software breakpoint at the specified address or symbol. Args: address_or_symbol: Address or symbol to set the breakpoint at name: Optional name for the breakpoint bp_type: Type of software breakpoint to set singleshoot: Set a single-shot breakpoint Returns: Success \"\"\" bp_type_str = str(bp_type).lower() if singleshoot and bp_type_str != \"ss\": bp_type_str = f'ss{bp_type_str}' if isinstance(address_or_symbol, int): name = name or f\"bpx_{address_or_symbol:x}\" return self.cmd_sync(f'bpx 0x{address_or_symbol:x}, \"{name}\", {bp_type_str}') else: name = name or f\"bpx_{address_or_symbol.replace(' ', '_')}\" if '\"' in name: raise ValueError(\"Name cannot contain double quotes\") return self.cmd_sync(f'bpx {address_or_symbol}, \"{name}\", {bp_type_str}')","title":"set_breakpoint"},{"location":"api/breakpoints/#x64dbg_automate.X64DbgClient.set_hardware_breakpoint","text":"Sets a hardware breakpoint at the specified address or symbol. Parameters: Name Type Description Default address_or_symbol int | str Address or symbol to set the breakpoint at required bp_type HardwareBreakpointType Type of software breakpoint to set x size int breakpoint size, one of [1, 2, 4, 8] 1 Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def set_hardware_breakpoint(self, address_or_symbol: int | str, bp_type: HardwareBreakpointType = HardwareBreakpointType.x, size: int = 1) -> bool: \"\"\" Sets a hardware breakpoint at the specified address or symbol. Args: address_or_symbol: Address or symbol to set the breakpoint at bp_type: Type of software breakpoint to set size: breakpoint size, one of [1, 2, 4, 8] Returns: Success \"\"\" if size not in [1, 2, 4, 8]: raise ValueError(\"Invalid size\") if isinstance(address_or_symbol, int): return self.cmd_sync(f'bph 0x{address_or_symbol:x}, {bp_type}, {size}') else: return self.cmd_sync(f'bph {address_or_symbol}, {bp_type}, {size}')","title":"set_hardware_breakpoint"},{"location":"api/breakpoints/#x64dbg_automate.X64DbgClient.set_memory_breakpoint","text":"Sets a memory breakpoint at the specified address or symbol. Parameters: Name Type Description Default address_or_symbol int | str Address or symbol to set the breakpoint at required bp_type MemoryBreakpointType Type of software breakpoint to set a restore bool Restore the original memory protection True Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def set_memory_breakpoint(self, address_or_symbol: int | str, bp_type: MemoryBreakpointType = MemoryBreakpointType.a, restore: bool = True) -> bool: \"\"\" Sets a memory breakpoint at the specified address or symbol. Args: address_or_symbol: Address or symbol to set the breakpoint at bp_type: Type of software breakpoint to set restore: Restore the original memory protection Returns: Success \"\"\" if isinstance(address_or_symbol, int): return self.cmd_sync(f'bpm 0x{address_or_symbol:x}, {int(restore)}, {bp_type}') else: return self.cmd_sync(f'bpm {address_or_symbol}, {int(restore)}, {bp_type}')","title":"set_memory_breakpoint"},{"location":"api/breakpoints/#x64dbg_automate.X64DbgClient.clear_breakpoint","text":"Clears software breakpoint at the specified address, name, or symbol. Parameters: Name Type Description Default address_name_symbol_or_none int | str | None Address or symbol to remove the breakpoint at (None removes all breakpoints of this type) None Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def clear_breakpoint(self, address_name_symbol_or_none: int | str | None = None) -> bool: \"\"\" Clears software breakpoint at the specified address, name, or symbol. Args: address_name_symbol_or_none: Address or symbol to remove the breakpoint at (None removes all breakpoints of this type) Returns: Success \"\"\" if address_name_symbol_or_none is None: return self.cmd_sync('bpc') if isinstance(address_name_symbol_or_none, int): return self.cmd_sync(f'bpc 0x{address_name_symbol_or_none:x}') return self.cmd_sync(f'bpc \"{address_name_symbol_or_none}\"')","title":"clear_breakpoint"},{"location":"api/breakpoints/#x64dbg_automate.X64DbgClient.clear_hardware_breakpoint","text":"Clears hardware breakpoint at the specified address or symbol. Parameters: Name Type Description Default address_symbol_or_none int | str | None Address or symbol to remove the breakpoint at (None removes all breakpoints of this type) None Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def clear_hardware_breakpoint(self, address_symbol_or_none: int | str | None = None) -> bool: \"\"\" Clears hardware breakpoint at the specified address or symbol. Args: address_symbol_or_none: Address or symbol to remove the breakpoint at (None removes all breakpoints of this type) Returns: Success \"\"\" if address_symbol_or_none is None: return self.cmd_sync('bphc') if isinstance(address_symbol_or_none, int): return self.cmd_sync(f'bphc 0x{address_symbol_or_none:x}') return self.cmd_sync(f'bphc {address_symbol_or_none}')","title":"clear_hardware_breakpoint"},{"location":"api/breakpoints/#x64dbg_automate.X64DbgClient.clear_memory_breakpoint","text":"Clears memory breakpoint at the specified address or symbol. Parameters: Name Type Description Default address_symbol_or_none int | str | None Address or symbol to remove the breakpoint at (None removes all breakpoints of this type) None Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def clear_memory_breakpoint(self, address_symbol_or_none: int | str | None = None) -> bool: \"\"\" Clears memory breakpoint at the specified address or symbol. Args: address_symbol_or_none: Address or symbol to remove the breakpoint at (None removes all breakpoints of this type) Returns: Success \"\"\" if address_symbol_or_none is None: return self.cmd_sync('bpmc') if isinstance(address_symbol_or_none, int): return self.cmd_sync(f'bpmc 0x{address_symbol_or_none:x}') return self.cmd_sync(f'bpmc {address_symbol_or_none}')","title":"clear_memory_breakpoint"},{"location":"api/breakpoints/#x64dbg_automate.X64DbgClient.toggle_breakpoint","text":"Toggles software breakpoint at the specified address or symbol. Parameters: Name Type Description Default address_name_symbol_or_none int | str | None Address, name, or symbol to toggle the breakpoint at None on bool Enable or disable the breakpoint True Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def toggle_breakpoint(self, address_name_symbol_or_none: int | str | None = None, on: bool = True) -> bool: \"\"\" Toggles software breakpoint at the specified address or symbol. Args: address_name_symbol_or_none: Address, name, or symbol to toggle the breakpoint at on: Enable or disable the breakpoint Returns: Success \"\"\" toggle_cmd = 'bpe' if on else 'bpd' if isinstance(address_name_symbol_or_none, int): return self.cmd_sync(f'{toggle_cmd} 0x{address_name_symbol_or_none:x}') elif address_name_symbol_or_none is None: return self.cmd_sync(f'{toggle_cmd}') else: return self.cmd_sync(f'{toggle_cmd} {address_name_symbol_or_none}')","title":"toggle_breakpoint"},{"location":"api/breakpoints/#x64dbg_automate.X64DbgClient.toggle_hardware_breakpoint","text":"Toggles hardware breakpoint at the specified address or symbol. Parameters: Name Type Description Default address_symbol_or_none int | str | None Address or symbol to toggle the breakpoint at None on bool Enable or disable the breakpoint True Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def toggle_hardware_breakpoint(self, address_symbol_or_none: int | str | None = None, on: bool = True) -> bool: \"\"\" Toggles hardware breakpoint at the specified address or symbol. Args: address_symbol_or_none: Address or symbol to toggle the breakpoint at on: Enable or disable the breakpoint Returns: Success \"\"\" toggle_cmd = 'bphe' if on else 'bphd' if isinstance(address_symbol_or_none, int): return self.cmd_sync(f'{toggle_cmd} 0x{address_symbol_or_none:x}') elif address_symbol_or_none is None: return self.cmd_sync(f'{toggle_cmd}') else: return self.cmd_sync(f'{toggle_cmd} {address_symbol_or_none}')","title":"toggle_hardware_breakpoint"},{"location":"api/breakpoints/#x64dbg_automate.X64DbgClient.toggle_memory_breakpoint","text":"Toggles memory breakpoint at the specified address or symbol. Parameters: Name Type Description Default address_symbol_or_none int | str | None Address or symbol to toggle the breakpoint at None on bool Enable or disable the breakpoint True Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def toggle_memory_breakpoint(self, address_symbol_or_none: int | str | None = None, on: bool = True) -> bool: \"\"\" Toggles memory breakpoint at the specified address or symbol. Args: address_symbol_or_none: Address or symbol to toggle the breakpoint at on: Enable or disable the breakpoint Returns: Success \"\"\" toggle_cmd = 'bpme' if on else 'bpmd' if isinstance(address_symbol_or_none, int): return self.cmd_sync(f'{toggle_cmd} 0x{address_symbol_or_none:x}') elif address_symbol_or_none is None: return self.cmd_sync(f'{toggle_cmd}') else: return self.cmd_sync(f'{toggle_cmd} {address_symbol_or_none}')","title":"toggle_memory_breakpoint"},{"location":"api/breakpoints/#api-model-reference","text":"","title":"API Model Reference"},{"location":"api/breakpoints/#x64dbg_automate.models.Breakpoint","text":"Source code in x64dbg_automate\\models.py class Breakpoint(BaseModel): type: BreakpointType addr: int enabled: bool singleshoot: bool active: bool name: str mod: str slot: int typeEx: int hwSize: int hitCount: int fastResume: bool silent: bool breakCondition: str logText: str logCondition: str commandText: str commandCondition: str","title":"Breakpoint"},{"location":"api/breakpoints/#x64dbg_automate.models.BreakpointType","text":"Source code in x64dbg_automate\\models.py class BreakpointType(IntEnum): BpNone = 0, BpNormal = 1, BpHardware = 2, BpMemory = 4, BpDll = 8, BpException = 16","title":"BreakpointType"},{"location":"api/breakpoints/#x64dbg_automate.models.StandardBreakpointType","text":"Source code in x64dbg_automate\\models.py class StandardBreakpointType(StrEnum): SingleShotInt3 = 'ss' # CC (SingleShoot) Long = 'long' # CD03 Ud2 = 'ud2' # 0F0B Short = 'short' # CC","title":"StandardBreakpointType"},{"location":"api/breakpoints/#x64dbg_automate.models.HardwareBreakpointType","text":"Source code in x64dbg_automate\\models.py class HardwareBreakpointType(StrEnum): r = 'r' w = 'w' x = 'x'","title":"HardwareBreakpointType"},{"location":"api/breakpoints/#x64dbg_automate.models.MemoryBreakpointType","text":"Source code in x64dbg_automate\\models.py class MemoryBreakpointType(StrEnum): r = 'r' w = 'w' x = 'x' a = 'a'","title":"MemoryBreakpointType"},{"location":"api/commands/","text":"Commands and Extensibility While x64dbg Automate strives to provide an idiomatic and easy to understand abstraction layer on top of the command execution abilities of x64dbg, it would be foolhardy to say every feature is covered perfectly for every use case. Raw command execution capabilities allow users to extend and customize x64dbg Automate beyond the built-in abstractions. API Method Reference cmd_sync(cmd_str) Evaluates a command and returns the success or failure. See: https://help.x64dbg.com/en/latest/commands/ Parameters: Name Type Description Default cmd_str str The command to execute required Returns: Type Description bool Success Source code in x64dbg_automate\\commands_xauto.py def cmd_sync(self, cmd_str: str) -> bool: \"\"\" Evaluates a command and returns the success or failure. See: [https://help.x64dbg.com/en/latest/commands/](https://help.x64dbg.com/en/latest/commands/) Args: cmd_str: The command to execute Returns: Success \"\"\" return self._send_request(XAutoCommand.XAUTO_REQ_DBG_CMD_EXEC_DIRECT, cmd_str)","title":"Commands and Extensibility"},{"location":"api/commands/#commands-and-extensibility","text":"While x64dbg Automate strives to provide an idiomatic and easy to understand abstraction layer on top of the command execution abilities of x64dbg, it would be foolhardy to say every feature is covered perfectly for every use case. Raw command execution capabilities allow users to extend and customize x64dbg Automate beyond the built-in abstractions.","title":"Commands and Extensibility"},{"location":"api/commands/#api-method-reference","text":"","title":"API Method Reference"},{"location":"api/commands/#x64dbg_automate.X64DbgClient.cmd_sync","text":"Evaluates a command and returns the success or failure. See: https://help.x64dbg.com/en/latest/commands/ Parameters: Name Type Description Default cmd_str str The command to execute required Returns: Type Description bool Success Source code in x64dbg_automate\\commands_xauto.py def cmd_sync(self, cmd_str: str) -> bool: \"\"\" Evaluates a command and returns the success or failure. See: [https://help.x64dbg.com/en/latest/commands/](https://help.x64dbg.com/en/latest/commands/) Args: cmd_str: The command to execute Returns: Success \"\"\" return self._send_request(XAutoCommand.XAUTO_REQ_DBG_CMD_EXEC_DIRECT, cmd_str)","title":"cmd_sync"},{"location":"api/debug-control/","text":"Debug Control What is Debug Control? Debug control refers to performing actions that change the state of the running debugger. Examples include: Loading/unloading a debugee Transitioning from stopped to running or visa-versa Switching thread contexts Single-stepping Running until return It's helpful to think of changing the debuggers state as two-steps: Requesting the change in state Waiting for the expected state Without explicit waits its easy to end up with race conditions and poor repeatability in scripts. # Good client.set_breakpoint(0x00401000, singleshoot=True) client.go() client.wait_for_debug_event(EventType.EVENT_BREAKPOINT) # Retrieved RIP after debugger reached target state print(client.get_reg('eip')) # Bad client.set_breakpoint(0x00401000, singleshoot=True) client.go() # Retrieved RIP without wait. It's possible to read an unintended value before the breakpoint is hit print(client.get_reg('eip')) Example: Debug Control \"\"\" Example: Debug Control (32/64 bit) \"\"\" import sys from x64dbg_automate import X64DbgClient if len(sys.argv) != 2: print(\"Usage: python sessions.py <x64dbg_path>\") quit(1) print('[+] Creating the x64dbg Automate session') client = X64DbgClient(x64dbg_path=sys.argv[1]) client.start_session() print('[+] Loading notepad and asking it to open a file') client.load_executable('C:\\\\Windows\\\\System32\\\\notepad.exe', 'C:\\\\Users\\\\desktop.ini') print('[+] Resuming from system breakpoint') client.go() print('[+] Waiting until the debugee is stopped at the entrypoint') client.wait_until_stopped() print('[+] Stepping-in 3 times') client.stepi(3) print('[+] Resuming from entrypoint + 3 step-ins') client.go() print('[+] Pausing the debugee') client.pause() print('[+] Resuming the debugee') client.go() print('[+] Unloading notepad') client.unload_executable() print('[+] Detaching the session') client.detach_session() [+] Creating the x64dbg Automate session [+] Loading notepad and asking it to open a file [+] Resuming from system breakpoint [+] Waiting until the debugee is stopped at the entrypoint [+] Stepping-in 3 times [+] Resuming from entrypoint + 3 step-ins [+] Pausing the debugee [+] Resuming the debugee [+] Unloading notepad [+] Detaching the session API Method Reference load_executable(target_exe, cmdline='', current_dir='', wait_timeout=10) Loads a new executable into the debugger. This method will block until the debugee is ready to receive a command. Parameters: Name Type Description Default target_exe str Path to the executable to load required cmdline str Command line arguments to pass to the executable '' current_dir str Current working directory for the executable '' wait_timeout int Max time to wait for the debugee to be ready 10 Returns: Type Description bool True if successful, False otherwise Source code in x64dbg_automate\\hla_xauto.py def load_executable(self, target_exe: str, cmdline: str = \"\", current_dir: str = \"\", wait_timeout: int = 10) -> bool: \"\"\" Loads a new executable into the debugger. This method will block until the debugee is ready to receive a command. Args: target_exe: Path to the executable to load cmdline: Command line arguments to pass to the executable current_dir: Current working directory for the executable wait_timeout: Max time to wait for the debugee to be ready Returns: True if successful, False otherwise \"\"\" cmdline = cmdline.replace('\"', r'\\\"') current_dir = current_dir.replace('\"', r'\\\"') if len(current_dir) == 0: current_dir = \".\" if not self.cmd_sync(f'init {target_exe}, \"{cmdline}\", \"{current_dir}\"'): return False return self.wait_cmd_ready(wait_timeout) unload_executable(wait_timeout=10) Unloads the currently loaded executable. This method will block until the debugger is no longer debugging. Parameters: Name Type Description Default wait_timeout int Max time to wait for the debugger finish unloading 10 Returns: Type Description bool True if successful, False otherwise Source code in x64dbg_automate\\hla_xauto.py def unload_executable(self, wait_timeout: int = 10) -> bool: \"\"\" Unloads the currently loaded executable. This method will block until the debugger is no longer debugging. Args: wait_timeout: Max time to wait for the debugger finish unloading Returns: True if successful, False otherwise \"\"\" if not self.cmd_sync(f'stop'): return False return self.wait_until_not_debugging(wait_timeout) go(pass_exceptions=False, swallow_exceptions=False) Resumes the debugee. This method will block until the debugee is in the running state. Parameters: Name Type Description Default pass_exceptions bool Pass exceptions to the debugee False swallow_exceptions bool Swallow exceptions False Returns: Type Description bool True if successful, False otherwise Source code in x64dbg_automate\\hla_xauto.py def go(self, pass_exceptions: bool = False, swallow_exceptions: bool = False) -> bool: \"\"\" Resumes the debugee. This method will block until the debugee is in the running state. Args: pass_exceptions: Pass exceptions to the debugee swallow_exceptions: Swallow exceptions Returns: True if successful, False otherwise \"\"\" if pass_exceptions == True and swallow_exceptions == True: raise ValueError(\"Cannot pass and swallow exceptions at the same time\") if pass_exceptions: prefix = 'e' elif swallow_exceptions: prefix = 'se' else: prefix = '' if not self.cmd_sync(f\"{prefix}go\"): return False self.wait_until_running(timeout=1) return True pause() Pauses the debugee. This method will block until the debugee is in the stopped state. Returns: Type Description bool True if successful, False otherwise Source code in x64dbg_automate\\hla_xauto.py def pause(self) -> bool: \"\"\" Pauses the debugee. This method will block until the debugee is in the stopped state. Returns: True if successful, False otherwise \"\"\" if not self.cmd_sync(f\"pause\"): return False return self.wait_until_stopped() stepi(step_count=1, pass_exceptions=False, swallow_exceptions=False, wait_for_ready=True, wait_timeout=2) Steps into N instructions. Parameters: Name Type Description Default step_count int Number of instructions to step through 1 pass_exceptions bool Pass exceptions to the debugee during step False swallow_exceptions bool Swallow exceptions during step False wait_for_ready bool Block until debugger is stopped True wait_timeout int Maximum time in seconds to wait for debugger to stop 2 Returns: bool: True if stepping operation was successful, False otherwise. Raises: ValueError: If both pass_exceptions and swallow_exceptions are True. Source code in x64dbg_automate\\hla_xauto.py def stepi(self, step_count: int = 1, pass_exceptions: bool = False, swallow_exceptions: bool = False, wait_for_ready: bool = True, wait_timeout: int = 2) -> bool: \"\"\" Steps into N instructions. Args: step_count: Number of instructions to step through pass_exceptions: Pass exceptions to the debugee during step swallow_exceptions: Swallow exceptions during step wait_for_ready: Block until debugger is stopped wait_timeout: Maximum time in seconds to wait for debugger to stop Returns: bool: True if stepping operation was successful, False otherwise. Raises: ValueError: If both pass_exceptions and swallow_exceptions are True. \"\"\" if pass_exceptions == True and swallow_exceptions == True: raise ValueError(\"Cannot pass and swallow exceptions at the same time\") if pass_exceptions: prefix = 'e' elif swallow_exceptions: prefix = 'se' else: prefix = '' res = self.cmd_sync(f\"{prefix}sti 0x{step_count:x}\") if res and wait_for_ready: self.wait_until_stopped(wait_timeout) return res stepo(step_count=1, pass_exceptions=False, swallow_exceptions=False, wait_for_ready=True, wait_timeout=2) Steps over N instructions. Parameters: Name Type Description Default step_count int Number of instructions to step through 1 pass_exceptions bool Pass exceptions to the debugee during step False swallow_exceptions bool Swallow exceptions during step False wait_for_ready bool Block until debugger is stopped True wait_timeout int Maximum time in seconds to wait for debugger to stop 2 Returns: bool: True if stepping operation was successful, False otherwise. Raises: ValueError: If both pass_exceptions and swallow_exceptions are True. Source code in x64dbg_automate\\hla_xauto.py def stepo(self, step_count: int = 1, pass_exceptions: bool = False, swallow_exceptions: bool = False, wait_for_ready: bool = True, wait_timeout: int = 2) -> bool: \"\"\" Steps over N instructions. Args: step_count: Number of instructions to step through pass_exceptions: Pass exceptions to the debugee during step swallow_exceptions: Swallow exceptions during step wait_for_ready: Block until debugger is stopped wait_timeout: Maximum time in seconds to wait for debugger to stop Returns: bool: True if stepping operation was successful, False otherwise. Raises: ValueError: If both pass_exceptions and swallow_exceptions are True. \"\"\" if pass_exceptions == True and swallow_exceptions == True: raise ValueError(\"Cannot pass and swallow exceptions at the same time\") if pass_exceptions: prefix = 'e' elif swallow_exceptions: prefix = 'se' else: prefix = '' res = self.cmd_sync(f\"{prefix}sto 0x{step_count:x}\") if res and wait_for_ready: self.wait_until_stopped(wait_timeout) return res skip(skip_count=1, wait_for_ready=True, wait_timeout=2) Skips over N instructions. Parameters: Name Type Description Default skip_count int Number of instructions to skip 1 wait_for_ready bool Block until debugger is stopped True wait_timeout int Maximum time in seconds to wait for debugger to stop 2 Returns: bool: True if stepping operation was successful, False otherwise. Source code in x64dbg_automate\\hla_xauto.py def skip(self, skip_count: int = 1, wait_for_ready: bool = True, wait_timeout: int = 2) -> bool: \"\"\" Skips over N instructions. Args: skip_count: Number of instructions to skip wait_for_ready: Block until debugger is stopped wait_timeout: Maximum time in seconds to wait for debugger to stop Returns: bool: True if stepping operation was successful, False otherwise. \"\"\" res = self.cmd_sync(f\"skip {skip_count}\") if res and wait_for_ready: self.wait_until_stopped(wait_timeout) return res ret(frames=1, wait_timeout=10) Steps until a ret instruction is encountered. Parameters: Name Type Description Default frames int Number of ret instructions to seek 1 wait_timeout int Maximum time in seconds to wait for debugger to stop 10 Returns: bool: True if stepping operation was successful, False otherwise. Source code in x64dbg_automate\\hla_xauto.py def ret(self, frames: int = 1, wait_timeout: int = 10) -> bool: \"\"\" Steps until a ret instruction is encountered. Args: frames: Number of ret instructions to seek wait_timeout: Maximum time in seconds to wait for debugger to stop Returns: bool: True if stepping operation was successful, False otherwise. \"\"\" if not self.cmd_sync(f\"rtr {frames}\"): return False return self.wait_cmd_ready(wait_timeout) thread_create(addr, arg=0) Create a new thread in the debugee. Parameters: Name Type Description Default addr int Address of the thread entry point required arg int Argument to pass to the thread 0 Source code in x64dbg_automate\\hla_xauto.py def thread_create(self, addr: int, arg: int = 0) -> int | None: \"\"\" Create a new thread in the debugee. Args: addr: Address of the thread entry point arg: Argument to pass to the thread \"\"\" success = self.cmd_sync(f'createthread 0x{addr:x}, 0x{arg:x}') if not success: return None tid, success = self.eval_sync('$result') if not success: return None return tid thread_terminate(tid) Kills a thread in the debugee. Parameters: Name Type Description Default tid int Thread ID to kill required Source code in x64dbg_automate\\hla_xauto.py def thread_terminate(self, tid: int): \"\"\" Kills a thread in the debugee. Args: tid: Thread ID to kill \"\"\" return self.cmd_sync(f'killthread 0x{tid:x}') thread_pause(tid) Pauses a thread in the debugee. Parameters: Name Type Description Default tid int Thread ID to kill required Source code in x64dbg_automate\\hla_xauto.py def thread_pause(self, tid: int): \"\"\" Pauses a thread in the debugee. Args: tid: Thread ID to kill \"\"\" return self.cmd_sync(f'suspendthread 0x{tid:x}') thread_resume(tid) Resumes a thread in the debugee. Parameters: Name Type Description Default tid int Thread ID to kill required Source code in x64dbg_automate\\hla_xauto.py def thread_resume(self, tid: int): \"\"\" Resumes a thread in the debugee. Args: tid: Thread ID to kill \"\"\" return self.cmd_sync(f'resumethread 0x{tid:x}') switch_thread(tid) Switches the currently observed debugger thread. Parameters: Name Type Description Default tid int Thread ID to kill required Source code in x64dbg_automate\\hla_xauto.py def switch_thread(self, tid: int): \"\"\" Switches the currently observed debugger thread. Args: tid: Thread ID to kill \"\"\" return self.cmd_sync(f'switchthread 0x{tid:x}') wait_for_debug_event(event_type, timeout=5) Wait for a debug event of a specific type to occur. This method returns the latest event of the specified type, which may have occurred before the method was called. Returned events are removed from the queue. If the event has not occurred within the timeout, None is returned. clear_debug_events can be used to ensure an empty debug event queue before calling this method. Parameters: Name Type Description Default event_type EventType The type of event to wait for required timeout int The maximum time to wait for the event in seconds 5 Returns: Type Description DbgEvent | None DbgEvent | None: The latest event of the specified type, or None if the event did not occur within the timeout. Source code in x64dbg_automate\\events.py def wait_for_debug_event(self, event_type: EventType, timeout: int = 5) -> DbgEvent | None: \"\"\" Wait for a debug event of a specific type to occur. This method returns the latest event of the specified type, which may have occurred before the method was called. Returned events are removed from the queue. If the event has not occurred within the timeout, None is returned. `clear_debug_events` can be used to ensure an empty debug event queue before calling this method. Args: event_type: The type of event to wait for timeout: The maximum time to wait for the event in seconds Returns: DbgEvent | None: The latest event of the specified type, or None if the event did not occur within the timeout. \"\"\" while timeout > 0: for ix, event in enumerate(self._debug_events_q): if event.event_type == event_type: return self._debug_events_q.pop(ix) time.sleep(0.25) timeout -= 0.25 return None clear_debug_events(event_type=None) Clear the debug event queue. If event_type is specified, only events of that type will be removed. Parameters: Name Type Description Default event_type EventType | None The type of event to clear. If None, all events will be cleared. None Source code in x64dbg_automate\\events.py def clear_debug_events(self, event_type: EventType | None = None) -> None: \"\"\" Clear the debug event queue. If `event_type` is specified, only events of that type will be removed. Args: event_type: The type of event to clear. If None, all events will be cleared. \"\"\" filtered = [] for _ in range(len(self._debug_events_q)): event = self._debug_events_q.pop(0) if event.event_type != event_type and event_type is not None: filtered.append(event) self._debug_events_q = filtered watch_debug_event(event_type, callback) Register a callback to be invoked when a debug event of a specific type occurs. Parameters: Name Type Description Default event_type EventType The type of event to watch required callback callable The callback to invoke when the event occurs. The callback should accept a single argument of type DbgEvent . required Source code in x64dbg_automate\\events.py def watch_debug_event(self, event_type: EventType, callback: callable): \"\"\" Register a callback to be invoked when a debug event of a specific type occurs. Args: event_type: The type of event to watch callback: The callback to invoke when the event occurs. The callback should accept a single argument of type `DbgEvent`. \"\"\" self.listeners[event_type] = self.listeners.get(event_type, []) + [callback] unwatch_debug_event(event_type, callback) Remove a callback registered with watch_debug_event Parameters: Name Type Description Default event_type EventType The type of event to unwatch required callback callable The callback instance to remove required Source code in x64dbg_automate\\events.py def unwatch_debug_event(self, event_type: EventType, callback: callable): \"\"\" Remove a callback registered with `watch_debug_event` Args: event_type: The type of event to unwatch callback: The callback instance to remove \"\"\" self.listeners[event_type] = [x for x in self.listeners.get(event_type, []) if x != callback] get_latest_debug_event() Get the latest debug event that occurred in the debugee. The event is removed from the queue. Source code in x64dbg_automate\\events.py def get_latest_debug_event(self) -> DbgEvent | None: \"\"\" Get the latest debug event that occurred in the debugee. The event is removed from the queue. \"\"\" if len(self._debug_events_q) == 0: return None return self._debug_events_q.pop() peek_latest_debug_event() Get the latest debug event that occurred in the debugee. The event is not removed from the queue. Source code in x64dbg_automate\\events.py def peek_latest_debug_event(self) -> DbgEvent | None: \"\"\" Get the latest debug event that occurred in the debugee. The event is not removed from the queue. \"\"\" if len(self._debug_events_q) == 0: return None return self._debug_events_q[-1] wait_until_debugging(timeout=10) Blocks until the debugger enters a debugging state Parameters: Name Type Description Default timeout int The maximum time to wait in seconds 10 Returns: Type Description bool True if the debugger is debugging, False otherwise Source code in x64dbg_automate\\commands_xauto.py def wait_until_debugging(self, timeout: int = 10) -> bool: \"\"\" Blocks until the debugger enters a debugging state Args: timeout: The maximum time to wait in seconds Returns: True if the debugger is debugging, False otherwise \"\"\" slept = 0 while True: if self.is_debugging(): return True time.sleep(0.2) slept += 0.2 if slept >= timeout: return False wait_until_not_debugging(timeout=10) Blocks until the debugger enters a not-debugging state Parameters: Name Type Description Default timeout int The maximum time to wait in seconds 10 Returns: Type Description bool True if the debugger is not-debugging, False otherwise Source code in x64dbg_automate\\commands_xauto.py def wait_until_not_debugging(self, timeout: int = 10) -> bool: \"\"\" Blocks until the debugger enters a not-debugging state Args: timeout: The maximum time to wait in seconds Returns: True if the debugger is not-debugging, False otherwise \"\"\" slept = 0 while True: if not self.is_debugging(): return True time.sleep(0.2) slept += 0.2 if slept >= timeout: return False wait_until_running(timeout=10) Blocks until the debugger enters a running state Parameters: Name Type Description Default timeout int The maximum time to wait in seconds 10 Returns: Type Description bool True if the debugger is running, False otherwise Source code in x64dbg_automate\\commands_xauto.py def wait_until_running(self, timeout: int = 10) -> bool: \"\"\" Blocks until the debugger enters a running state Args: timeout: The maximum time to wait in seconds Returns: True if the debugger is running, False otherwise \"\"\" slept = 0 while True: if self.is_running(): return True time.sleep(0.08) slept += 0.08 if slept >= timeout: return False wait_until_stopped(timeout=10) Blocks until the debugger enters a stopped state Parameters: Name Type Description Default timeout int The maximum time to wait in seconds 10 Returns: Type Description bool True if the debugger is stopped, False otherwise Source code in x64dbg_automate\\commands_xauto.py def wait_until_stopped(self, timeout: int = 10) -> bool: \"\"\" Blocks until the debugger enters a stopped state Args: timeout: The maximum time to wait in seconds Returns: True if the debugger is stopped, False otherwise \"\"\" slept = 0 while True: if not self.is_running() or not self.is_debugging(): return True time.sleep(0.2) slept += 0.2 if slept >= timeout: return False wait_cmd_ready(timeout=10) Blocks until the debugger is ready to accept debug control commands (debugging + stopped) Parameters: Name Type Description Default timeout int The maximum time to wait in seconds 10 Returns: Type Description bool True if the debugger is ready, False otherwise Source code in x64dbg_automate\\commands_xauto.py def wait_cmd_ready(self, timeout: int = 10) -> bool: \"\"\" Blocks until the debugger is ready to accept debug control commands (debugging + stopped) Args: timeout: The maximum time to wait in seconds Returns: True if the debugger is ready, False otherwise \"\"\" return self.wait_until_debugging(timeout) and self.wait_until_stopped(timeout) hide_debugger_peb() Hides the debugger in the debugee's PEB Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def hide_debugger_peb(self) -> bool: \"\"\" Hides the debugger in the debugee's PEB Returns: Success \"\"\" return self.cmd_sync(f'hide') debugee_pid() Retrieves the PID of the debugee Returns: Type Description int | None PID of the debugee, or None if the debugger is not debugging Source code in x64dbg_automate\\hla_xauto.py def debugee_pid(self) -> int | None: \"\"\" Retrieves the PID of the debugee Returns: PID of the debugee, or None if the debugger is not debugging \"\"\" if self.is_debugging(): pid, res = self.eval_sync(f'pid') if res: return pid return None get_debugger_pid() Retrieves the PID of the x64dbg process Returns: Type Description int The PID of the x64dbg process Source code in x64dbg_automate\\commands_xauto.py def get_debugger_pid(self) -> int: \"\"\" Retrieves the PID of the x64dbg process Returns: The PID of the x64dbg process \"\"\" return self._send_request(XAutoCommand.XAUTO_REQ_DEBUGGER_PID) is_running() Checks if the debugee's state is \"running\" Returns: Type Description bool True if the debugee is running, False otherwise Source code in x64dbg_automate\\commands_xauto.py def is_running(self) -> bool: \"\"\" Checks if the debugee's state is \"running\" Returns: True if the debugee is running, False otherwise \"\"\" return self._send_request(XAutoCommand.XAUTO_REQ_DBG_IS_RUNNING) is_debugging() Checks if the debugee's state is \"debugging\" Returns: Type Description bool True if the debugee is running, False otherwise Source code in x64dbg_automate\\commands_xauto.py def is_debugging(self) -> bool: \"\"\" Checks if the debugee's state is \"debugging\" Returns: True if the debugee is running, False otherwise \"\"\" return self._send_request(XAutoCommand.XAUTO_REQ_DBG_IS_DEBUGGING) API Model Reference DbgEvent Source code in x64dbg_automate\\events.py class DbgEvent(): def __init__(self, event_type: str, event_data: list[any]): self.event_type = event_type if event_type == EventType.EVENT_BREAKPOINT: self.event_data = BreakpointEventData( type=event_data[0], addr=event_data[1], enabled=event_data[2], singleshoot=event_data[3], active=event_data[4], name=event_data[5], mod=event_data[6], slot=event_data[7], typeEx=event_data[8], hwSize=event_data[9], hitCount=event_data[10], fastResume=event_data[11], silent=event_data[12], breakCondition=event_data[13], logText=event_data[14], logCondition=event_data[15], commandText=event_data[16], commandCondition=event_data[17] ) elif event_type == EventType.EVENT_SYSTEMBREAKPOINT: self.event_data = SysBreakpointEventData( reserved=event_data[0] ) elif event_type == EventType.EVENT_CREATE_THREAD: self.event_data = CreateThreadEventData( dwThreadId=event_data[0], lpThreadLocalBase=event_data[1], lpStartAddress=event_data[2] ) elif event_type == EventType.EVENT_EXIT_THREAD: self.event_data = ExitThreadEventData( dwThreadId=event_data[0], dwExitCode=event_data[1] ) elif event_type == EventType.EVENT_LOAD_DLL: self.event_data = LoadDllEventData( modname=event_data[0], lpBaseOfDll=event_data[1] ) elif event_type == EventType.EVENT_UNLOAD_DLL: self.event_data = UnloadDllEventData( lpBaseOfDll=event_data[0] ) elif event_type == EventType.EVENT_OUTPUT_DEBUG_STRING: self.event_data = OutputDebugStringEventData( lpDebugStringData=event_data[0] ) elif event_type == EventType.EVENT_EXCEPTION: self.event_data = ExceptionEventData( ExceptionCode=event_data[0], ExceptionFlags=event_data[1], ExceptionRecord=event_data[2], ExceptionAddress=event_data[3], NumberParameters=event_data[4], ExceptionInformation=event_data[5], dwFirstChance=event_data[6] ) else: raise ValueError(f\"Unknown event type: {event_type}\") EventType Source code in x64dbg_automate\\events.py class EventType(StrEnum): EVENT_BREAKPOINT = \"EVENT_BREAKPOINT\" EVENT_SYSTEMBREAKPOINT = \"EVENT_SYSTEMBREAKPOINT\" EVENT_CREATE_THREAD = \"EVENT_CREATE_THREAD\" EVENT_EXIT_THREAD = \"EVENT_EXIT_THREAD\" EVENT_LOAD_DLL = \"EVENT_LOAD_DLL\" EVENT_UNLOAD_DLL = \"EVENT_UNLOAD_DLL\" EVENT_OUTPUT_DEBUG_STRING = \"EVENT_OUTPUT_DEBUG_STRING\" EVENT_EXCEPTION = \"EVENT_EXCEPTION\"","title":"Debug Control"},{"location":"api/debug-control/#debug-control","text":"","title":"Debug Control"},{"location":"api/debug-control/#what-is-debug-control","text":"Debug control refers to performing actions that change the state of the running debugger. Examples include: Loading/unloading a debugee Transitioning from stopped to running or visa-versa Switching thread contexts Single-stepping Running until return It's helpful to think of changing the debuggers state as two-steps: Requesting the change in state Waiting for the expected state Without explicit waits its easy to end up with race conditions and poor repeatability in scripts. # Good client.set_breakpoint(0x00401000, singleshoot=True) client.go() client.wait_for_debug_event(EventType.EVENT_BREAKPOINT) # Retrieved RIP after debugger reached target state print(client.get_reg('eip')) # Bad client.set_breakpoint(0x00401000, singleshoot=True) client.go() # Retrieved RIP without wait. It's possible to read an unintended value before the breakpoint is hit print(client.get_reg('eip'))","title":"What is Debug Control?"},{"location":"api/debug-control/#example-debug-control","text":"\"\"\" Example: Debug Control (32/64 bit) \"\"\" import sys from x64dbg_automate import X64DbgClient if len(sys.argv) != 2: print(\"Usage: python sessions.py <x64dbg_path>\") quit(1) print('[+] Creating the x64dbg Automate session') client = X64DbgClient(x64dbg_path=sys.argv[1]) client.start_session() print('[+] Loading notepad and asking it to open a file') client.load_executable('C:\\\\Windows\\\\System32\\\\notepad.exe', 'C:\\\\Users\\\\desktop.ini') print('[+] Resuming from system breakpoint') client.go() print('[+] Waiting until the debugee is stopped at the entrypoint') client.wait_until_stopped() print('[+] Stepping-in 3 times') client.stepi(3) print('[+] Resuming from entrypoint + 3 step-ins') client.go() print('[+] Pausing the debugee') client.pause() print('[+] Resuming the debugee') client.go() print('[+] Unloading notepad') client.unload_executable() print('[+] Detaching the session') client.detach_session() [+] Creating the x64dbg Automate session [+] Loading notepad and asking it to open a file [+] Resuming from system breakpoint [+] Waiting until the debugee is stopped at the entrypoint [+] Stepping-in 3 times [+] Resuming from entrypoint + 3 step-ins [+] Pausing the debugee [+] Resuming the debugee [+] Unloading notepad [+] Detaching the session","title":"Example: Debug Control"},{"location":"api/debug-control/#api-method-reference","text":"","title":"API Method Reference"},{"location":"api/debug-control/#x64dbg_automate.X64DbgClient.load_executable","text":"Loads a new executable into the debugger. This method will block until the debugee is ready to receive a command. Parameters: Name Type Description Default target_exe str Path to the executable to load required cmdline str Command line arguments to pass to the executable '' current_dir str Current working directory for the executable '' wait_timeout int Max time to wait for the debugee to be ready 10 Returns: Type Description bool True if successful, False otherwise Source code in x64dbg_automate\\hla_xauto.py def load_executable(self, target_exe: str, cmdline: str = \"\", current_dir: str = \"\", wait_timeout: int = 10) -> bool: \"\"\" Loads a new executable into the debugger. This method will block until the debugee is ready to receive a command. Args: target_exe: Path to the executable to load cmdline: Command line arguments to pass to the executable current_dir: Current working directory for the executable wait_timeout: Max time to wait for the debugee to be ready Returns: True if successful, False otherwise \"\"\" cmdline = cmdline.replace('\"', r'\\\"') current_dir = current_dir.replace('\"', r'\\\"') if len(current_dir) == 0: current_dir = \".\" if not self.cmd_sync(f'init {target_exe}, \"{cmdline}\", \"{current_dir}\"'): return False return self.wait_cmd_ready(wait_timeout)","title":"load_executable"},{"location":"api/debug-control/#x64dbg_automate.X64DbgClient.unload_executable","text":"Unloads the currently loaded executable. This method will block until the debugger is no longer debugging. Parameters: Name Type Description Default wait_timeout int Max time to wait for the debugger finish unloading 10 Returns: Type Description bool True if successful, False otherwise Source code in x64dbg_automate\\hla_xauto.py def unload_executable(self, wait_timeout: int = 10) -> bool: \"\"\" Unloads the currently loaded executable. This method will block until the debugger is no longer debugging. Args: wait_timeout: Max time to wait for the debugger finish unloading Returns: True if successful, False otherwise \"\"\" if not self.cmd_sync(f'stop'): return False return self.wait_until_not_debugging(wait_timeout)","title":"unload_executable"},{"location":"api/debug-control/#x64dbg_automate.X64DbgClient.go","text":"Resumes the debugee. This method will block until the debugee is in the running state. Parameters: Name Type Description Default pass_exceptions bool Pass exceptions to the debugee False swallow_exceptions bool Swallow exceptions False Returns: Type Description bool True if successful, False otherwise Source code in x64dbg_automate\\hla_xauto.py def go(self, pass_exceptions: bool = False, swallow_exceptions: bool = False) -> bool: \"\"\" Resumes the debugee. This method will block until the debugee is in the running state. Args: pass_exceptions: Pass exceptions to the debugee swallow_exceptions: Swallow exceptions Returns: True if successful, False otherwise \"\"\" if pass_exceptions == True and swallow_exceptions == True: raise ValueError(\"Cannot pass and swallow exceptions at the same time\") if pass_exceptions: prefix = 'e' elif swallow_exceptions: prefix = 'se' else: prefix = '' if not self.cmd_sync(f\"{prefix}go\"): return False self.wait_until_running(timeout=1) return True","title":"go"},{"location":"api/debug-control/#x64dbg_automate.X64DbgClient.pause","text":"Pauses the debugee. This method will block until the debugee is in the stopped state. Returns: Type Description bool True if successful, False otherwise Source code in x64dbg_automate\\hla_xauto.py def pause(self) -> bool: \"\"\" Pauses the debugee. This method will block until the debugee is in the stopped state. Returns: True if successful, False otherwise \"\"\" if not self.cmd_sync(f\"pause\"): return False return self.wait_until_stopped()","title":"pause"},{"location":"api/debug-control/#x64dbg_automate.X64DbgClient.stepi","text":"Steps into N instructions. Parameters: Name Type Description Default step_count int Number of instructions to step through 1 pass_exceptions bool Pass exceptions to the debugee during step False swallow_exceptions bool Swallow exceptions during step False wait_for_ready bool Block until debugger is stopped True wait_timeout int Maximum time in seconds to wait for debugger to stop 2 Returns: bool: True if stepping operation was successful, False otherwise. Raises: ValueError: If both pass_exceptions and swallow_exceptions are True. Source code in x64dbg_automate\\hla_xauto.py def stepi(self, step_count: int = 1, pass_exceptions: bool = False, swallow_exceptions: bool = False, wait_for_ready: bool = True, wait_timeout: int = 2) -> bool: \"\"\" Steps into N instructions. Args: step_count: Number of instructions to step through pass_exceptions: Pass exceptions to the debugee during step swallow_exceptions: Swallow exceptions during step wait_for_ready: Block until debugger is stopped wait_timeout: Maximum time in seconds to wait for debugger to stop Returns: bool: True if stepping operation was successful, False otherwise. Raises: ValueError: If both pass_exceptions and swallow_exceptions are True. \"\"\" if pass_exceptions == True and swallow_exceptions == True: raise ValueError(\"Cannot pass and swallow exceptions at the same time\") if pass_exceptions: prefix = 'e' elif swallow_exceptions: prefix = 'se' else: prefix = '' res = self.cmd_sync(f\"{prefix}sti 0x{step_count:x}\") if res and wait_for_ready: self.wait_until_stopped(wait_timeout) return res","title":"stepi"},{"location":"api/debug-control/#x64dbg_automate.X64DbgClient.stepo","text":"Steps over N instructions. Parameters: Name Type Description Default step_count int Number of instructions to step through 1 pass_exceptions bool Pass exceptions to the debugee during step False swallow_exceptions bool Swallow exceptions during step False wait_for_ready bool Block until debugger is stopped True wait_timeout int Maximum time in seconds to wait for debugger to stop 2 Returns: bool: True if stepping operation was successful, False otherwise. Raises: ValueError: If both pass_exceptions and swallow_exceptions are True. Source code in x64dbg_automate\\hla_xauto.py def stepo(self, step_count: int = 1, pass_exceptions: bool = False, swallow_exceptions: bool = False, wait_for_ready: bool = True, wait_timeout: int = 2) -> bool: \"\"\" Steps over N instructions. Args: step_count: Number of instructions to step through pass_exceptions: Pass exceptions to the debugee during step swallow_exceptions: Swallow exceptions during step wait_for_ready: Block until debugger is stopped wait_timeout: Maximum time in seconds to wait for debugger to stop Returns: bool: True if stepping operation was successful, False otherwise. Raises: ValueError: If both pass_exceptions and swallow_exceptions are True. \"\"\" if pass_exceptions == True and swallow_exceptions == True: raise ValueError(\"Cannot pass and swallow exceptions at the same time\") if pass_exceptions: prefix = 'e' elif swallow_exceptions: prefix = 'se' else: prefix = '' res = self.cmd_sync(f\"{prefix}sto 0x{step_count:x}\") if res and wait_for_ready: self.wait_until_stopped(wait_timeout) return res","title":"stepo"},{"location":"api/debug-control/#x64dbg_automate.X64DbgClient.skip","text":"Skips over N instructions. Parameters: Name Type Description Default skip_count int Number of instructions to skip 1 wait_for_ready bool Block until debugger is stopped True wait_timeout int Maximum time in seconds to wait for debugger to stop 2 Returns: bool: True if stepping operation was successful, False otherwise. Source code in x64dbg_automate\\hla_xauto.py def skip(self, skip_count: int = 1, wait_for_ready: bool = True, wait_timeout: int = 2) -> bool: \"\"\" Skips over N instructions. Args: skip_count: Number of instructions to skip wait_for_ready: Block until debugger is stopped wait_timeout: Maximum time in seconds to wait for debugger to stop Returns: bool: True if stepping operation was successful, False otherwise. \"\"\" res = self.cmd_sync(f\"skip {skip_count}\") if res and wait_for_ready: self.wait_until_stopped(wait_timeout) return res","title":"skip"},{"location":"api/debug-control/#x64dbg_automate.X64DbgClient.ret","text":"Steps until a ret instruction is encountered. Parameters: Name Type Description Default frames int Number of ret instructions to seek 1 wait_timeout int Maximum time in seconds to wait for debugger to stop 10 Returns: bool: True if stepping operation was successful, False otherwise. Source code in x64dbg_automate\\hla_xauto.py def ret(self, frames: int = 1, wait_timeout: int = 10) -> bool: \"\"\" Steps until a ret instruction is encountered. Args: frames: Number of ret instructions to seek wait_timeout: Maximum time in seconds to wait for debugger to stop Returns: bool: True if stepping operation was successful, False otherwise. \"\"\" if not self.cmd_sync(f\"rtr {frames}\"): return False return self.wait_cmd_ready(wait_timeout)","title":"ret"},{"location":"api/debug-control/#x64dbg_automate.X64DbgClient.thread_create","text":"Create a new thread in the debugee. Parameters: Name Type Description Default addr int Address of the thread entry point required arg int Argument to pass to the thread 0 Source code in x64dbg_automate\\hla_xauto.py def thread_create(self, addr: int, arg: int = 0) -> int | None: \"\"\" Create a new thread in the debugee. Args: addr: Address of the thread entry point arg: Argument to pass to the thread \"\"\" success = self.cmd_sync(f'createthread 0x{addr:x}, 0x{arg:x}') if not success: return None tid, success = self.eval_sync('$result') if not success: return None return tid","title":"thread_create"},{"location":"api/debug-control/#x64dbg_automate.X64DbgClient.thread_terminate","text":"Kills a thread in the debugee. Parameters: Name Type Description Default tid int Thread ID to kill required Source code in x64dbg_automate\\hla_xauto.py def thread_terminate(self, tid: int): \"\"\" Kills a thread in the debugee. Args: tid: Thread ID to kill \"\"\" return self.cmd_sync(f'killthread 0x{tid:x}')","title":"thread_terminate"},{"location":"api/debug-control/#x64dbg_automate.X64DbgClient.thread_pause","text":"Pauses a thread in the debugee. Parameters: Name Type Description Default tid int Thread ID to kill required Source code in x64dbg_automate\\hla_xauto.py def thread_pause(self, tid: int): \"\"\" Pauses a thread in the debugee. Args: tid: Thread ID to kill \"\"\" return self.cmd_sync(f'suspendthread 0x{tid:x}')","title":"thread_pause"},{"location":"api/debug-control/#x64dbg_automate.X64DbgClient.thread_resume","text":"Resumes a thread in the debugee. Parameters: Name Type Description Default tid int Thread ID to kill required Source code in x64dbg_automate\\hla_xauto.py def thread_resume(self, tid: int): \"\"\" Resumes a thread in the debugee. Args: tid: Thread ID to kill \"\"\" return self.cmd_sync(f'resumethread 0x{tid:x}')","title":"thread_resume"},{"location":"api/debug-control/#x64dbg_automate.X64DbgClient.switch_thread","text":"Switches the currently observed debugger thread. Parameters: Name Type Description Default tid int Thread ID to kill required Source code in x64dbg_automate\\hla_xauto.py def switch_thread(self, tid: int): \"\"\" Switches the currently observed debugger thread. Args: tid: Thread ID to kill \"\"\" return self.cmd_sync(f'switchthread 0x{tid:x}')","title":"switch_thread"},{"location":"api/debug-control/#x64dbg_automate.X64DbgClient.wait_for_debug_event","text":"Wait for a debug event of a specific type to occur. This method returns the latest event of the specified type, which may have occurred before the method was called. Returned events are removed from the queue. If the event has not occurred within the timeout, None is returned. clear_debug_events can be used to ensure an empty debug event queue before calling this method. Parameters: Name Type Description Default event_type EventType The type of event to wait for required timeout int The maximum time to wait for the event in seconds 5 Returns: Type Description DbgEvent | None DbgEvent | None: The latest event of the specified type, or None if the event did not occur within the timeout. Source code in x64dbg_automate\\events.py def wait_for_debug_event(self, event_type: EventType, timeout: int = 5) -> DbgEvent | None: \"\"\" Wait for a debug event of a specific type to occur. This method returns the latest event of the specified type, which may have occurred before the method was called. Returned events are removed from the queue. If the event has not occurred within the timeout, None is returned. `clear_debug_events` can be used to ensure an empty debug event queue before calling this method. Args: event_type: The type of event to wait for timeout: The maximum time to wait for the event in seconds Returns: DbgEvent | None: The latest event of the specified type, or None if the event did not occur within the timeout. \"\"\" while timeout > 0: for ix, event in enumerate(self._debug_events_q): if event.event_type == event_type: return self._debug_events_q.pop(ix) time.sleep(0.25) timeout -= 0.25 return None","title":"wait_for_debug_event"},{"location":"api/debug-control/#x64dbg_automate.X64DbgClient.clear_debug_events","text":"Clear the debug event queue. If event_type is specified, only events of that type will be removed. Parameters: Name Type Description Default event_type EventType | None The type of event to clear. If None, all events will be cleared. None Source code in x64dbg_automate\\events.py def clear_debug_events(self, event_type: EventType | None = None) -> None: \"\"\" Clear the debug event queue. If `event_type` is specified, only events of that type will be removed. Args: event_type: The type of event to clear. If None, all events will be cleared. \"\"\" filtered = [] for _ in range(len(self._debug_events_q)): event = self._debug_events_q.pop(0) if event.event_type != event_type and event_type is not None: filtered.append(event) self._debug_events_q = filtered","title":"clear_debug_events"},{"location":"api/debug-control/#x64dbg_automate.X64DbgClient.watch_debug_event","text":"Register a callback to be invoked when a debug event of a specific type occurs. Parameters: Name Type Description Default event_type EventType The type of event to watch required callback callable The callback to invoke when the event occurs. The callback should accept a single argument of type DbgEvent . required Source code in x64dbg_automate\\events.py def watch_debug_event(self, event_type: EventType, callback: callable): \"\"\" Register a callback to be invoked when a debug event of a specific type occurs. Args: event_type: The type of event to watch callback: The callback to invoke when the event occurs. The callback should accept a single argument of type `DbgEvent`. \"\"\" self.listeners[event_type] = self.listeners.get(event_type, []) + [callback]","title":"watch_debug_event"},{"location":"api/debug-control/#x64dbg_automate.X64DbgClient.unwatch_debug_event","text":"Remove a callback registered with watch_debug_event Parameters: Name Type Description Default event_type EventType The type of event to unwatch required callback callable The callback instance to remove required Source code in x64dbg_automate\\events.py def unwatch_debug_event(self, event_type: EventType, callback: callable): \"\"\" Remove a callback registered with `watch_debug_event` Args: event_type: The type of event to unwatch callback: The callback instance to remove \"\"\" self.listeners[event_type] = [x for x in self.listeners.get(event_type, []) if x != callback]","title":"unwatch_debug_event"},{"location":"api/debug-control/#x64dbg_automate.X64DbgClient.get_latest_debug_event","text":"Get the latest debug event that occurred in the debugee. The event is removed from the queue. Source code in x64dbg_automate\\events.py def get_latest_debug_event(self) -> DbgEvent | None: \"\"\" Get the latest debug event that occurred in the debugee. The event is removed from the queue. \"\"\" if len(self._debug_events_q) == 0: return None return self._debug_events_q.pop()","title":"get_latest_debug_event"},{"location":"api/debug-control/#x64dbg_automate.X64DbgClient.peek_latest_debug_event","text":"Get the latest debug event that occurred in the debugee. The event is not removed from the queue. Source code in x64dbg_automate\\events.py def peek_latest_debug_event(self) -> DbgEvent | None: \"\"\" Get the latest debug event that occurred in the debugee. The event is not removed from the queue. \"\"\" if len(self._debug_events_q) == 0: return None return self._debug_events_q[-1]","title":"peek_latest_debug_event"},{"location":"api/debug-control/#x64dbg_automate.X64DbgClient.wait_until_debugging","text":"Blocks until the debugger enters a debugging state Parameters: Name Type Description Default timeout int The maximum time to wait in seconds 10 Returns: Type Description bool True if the debugger is debugging, False otherwise Source code in x64dbg_automate\\commands_xauto.py def wait_until_debugging(self, timeout: int = 10) -> bool: \"\"\" Blocks until the debugger enters a debugging state Args: timeout: The maximum time to wait in seconds Returns: True if the debugger is debugging, False otherwise \"\"\" slept = 0 while True: if self.is_debugging(): return True time.sleep(0.2) slept += 0.2 if slept >= timeout: return False","title":"wait_until_debugging"},{"location":"api/debug-control/#x64dbg_automate.X64DbgClient.wait_until_not_debugging","text":"Blocks until the debugger enters a not-debugging state Parameters: Name Type Description Default timeout int The maximum time to wait in seconds 10 Returns: Type Description bool True if the debugger is not-debugging, False otherwise Source code in x64dbg_automate\\commands_xauto.py def wait_until_not_debugging(self, timeout: int = 10) -> bool: \"\"\" Blocks until the debugger enters a not-debugging state Args: timeout: The maximum time to wait in seconds Returns: True if the debugger is not-debugging, False otherwise \"\"\" slept = 0 while True: if not self.is_debugging(): return True time.sleep(0.2) slept += 0.2 if slept >= timeout: return False","title":"wait_until_not_debugging"},{"location":"api/debug-control/#x64dbg_automate.X64DbgClient.wait_until_running","text":"Blocks until the debugger enters a running state Parameters: Name Type Description Default timeout int The maximum time to wait in seconds 10 Returns: Type Description bool True if the debugger is running, False otherwise Source code in x64dbg_automate\\commands_xauto.py def wait_until_running(self, timeout: int = 10) -> bool: \"\"\" Blocks until the debugger enters a running state Args: timeout: The maximum time to wait in seconds Returns: True if the debugger is running, False otherwise \"\"\" slept = 0 while True: if self.is_running(): return True time.sleep(0.08) slept += 0.08 if slept >= timeout: return False","title":"wait_until_running"},{"location":"api/debug-control/#x64dbg_automate.X64DbgClient.wait_until_stopped","text":"Blocks until the debugger enters a stopped state Parameters: Name Type Description Default timeout int The maximum time to wait in seconds 10 Returns: Type Description bool True if the debugger is stopped, False otherwise Source code in x64dbg_automate\\commands_xauto.py def wait_until_stopped(self, timeout: int = 10) -> bool: \"\"\" Blocks until the debugger enters a stopped state Args: timeout: The maximum time to wait in seconds Returns: True if the debugger is stopped, False otherwise \"\"\" slept = 0 while True: if not self.is_running() or not self.is_debugging(): return True time.sleep(0.2) slept += 0.2 if slept >= timeout: return False","title":"wait_until_stopped"},{"location":"api/debug-control/#x64dbg_automate.X64DbgClient.wait_cmd_ready","text":"Blocks until the debugger is ready to accept debug control commands (debugging + stopped) Parameters: Name Type Description Default timeout int The maximum time to wait in seconds 10 Returns: Type Description bool True if the debugger is ready, False otherwise Source code in x64dbg_automate\\commands_xauto.py def wait_cmd_ready(self, timeout: int = 10) -> bool: \"\"\" Blocks until the debugger is ready to accept debug control commands (debugging + stopped) Args: timeout: The maximum time to wait in seconds Returns: True if the debugger is ready, False otherwise \"\"\" return self.wait_until_debugging(timeout) and self.wait_until_stopped(timeout)","title":"wait_cmd_ready"},{"location":"api/debug-control/#x64dbg_automate.X64DbgClient.hide_debugger_peb","text":"Hides the debugger in the debugee's PEB Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def hide_debugger_peb(self) -> bool: \"\"\" Hides the debugger in the debugee's PEB Returns: Success \"\"\" return self.cmd_sync(f'hide')","title":"hide_debugger_peb"},{"location":"api/debug-control/#x64dbg_automate.X64DbgClient.debugee_pid","text":"Retrieves the PID of the debugee Returns: Type Description int | None PID of the debugee, or None if the debugger is not debugging Source code in x64dbg_automate\\hla_xauto.py def debugee_pid(self) -> int | None: \"\"\" Retrieves the PID of the debugee Returns: PID of the debugee, or None if the debugger is not debugging \"\"\" if self.is_debugging(): pid, res = self.eval_sync(f'pid') if res: return pid return None","title":"debugee_pid"},{"location":"api/debug-control/#x64dbg_automate.X64DbgClient.get_debugger_pid","text":"Retrieves the PID of the x64dbg process Returns: Type Description int The PID of the x64dbg process Source code in x64dbg_automate\\commands_xauto.py def get_debugger_pid(self) -> int: \"\"\" Retrieves the PID of the x64dbg process Returns: The PID of the x64dbg process \"\"\" return self._send_request(XAutoCommand.XAUTO_REQ_DEBUGGER_PID)","title":"get_debugger_pid"},{"location":"api/debug-control/#x64dbg_automate.X64DbgClient.is_running","text":"Checks if the debugee's state is \"running\" Returns: Type Description bool True if the debugee is running, False otherwise Source code in x64dbg_automate\\commands_xauto.py def is_running(self) -> bool: \"\"\" Checks if the debugee's state is \"running\" Returns: True if the debugee is running, False otherwise \"\"\" return self._send_request(XAutoCommand.XAUTO_REQ_DBG_IS_RUNNING)","title":"is_running"},{"location":"api/debug-control/#x64dbg_automate.X64DbgClient.is_debugging","text":"Checks if the debugee's state is \"debugging\" Returns: Type Description bool True if the debugee is running, False otherwise Source code in x64dbg_automate\\commands_xauto.py def is_debugging(self) -> bool: \"\"\" Checks if the debugee's state is \"debugging\" Returns: True if the debugee is running, False otherwise \"\"\" return self._send_request(XAutoCommand.XAUTO_REQ_DBG_IS_DEBUGGING)","title":"is_debugging"},{"location":"api/debug-control/#api-model-reference","text":"","title":"API Model Reference"},{"location":"api/debug-control/#x64dbg_automate.events.DbgEvent","text":"Source code in x64dbg_automate\\events.py class DbgEvent(): def __init__(self, event_type: str, event_data: list[any]): self.event_type = event_type if event_type == EventType.EVENT_BREAKPOINT: self.event_data = BreakpointEventData( type=event_data[0], addr=event_data[1], enabled=event_data[2], singleshoot=event_data[3], active=event_data[4], name=event_data[5], mod=event_data[6], slot=event_data[7], typeEx=event_data[8], hwSize=event_data[9], hitCount=event_data[10], fastResume=event_data[11], silent=event_data[12], breakCondition=event_data[13], logText=event_data[14], logCondition=event_data[15], commandText=event_data[16], commandCondition=event_data[17] ) elif event_type == EventType.EVENT_SYSTEMBREAKPOINT: self.event_data = SysBreakpointEventData( reserved=event_data[0] ) elif event_type == EventType.EVENT_CREATE_THREAD: self.event_data = CreateThreadEventData( dwThreadId=event_data[0], lpThreadLocalBase=event_data[1], lpStartAddress=event_data[2] ) elif event_type == EventType.EVENT_EXIT_THREAD: self.event_data = ExitThreadEventData( dwThreadId=event_data[0], dwExitCode=event_data[1] ) elif event_type == EventType.EVENT_LOAD_DLL: self.event_data = LoadDllEventData( modname=event_data[0], lpBaseOfDll=event_data[1] ) elif event_type == EventType.EVENT_UNLOAD_DLL: self.event_data = UnloadDllEventData( lpBaseOfDll=event_data[0] ) elif event_type == EventType.EVENT_OUTPUT_DEBUG_STRING: self.event_data = OutputDebugStringEventData( lpDebugStringData=event_data[0] ) elif event_type == EventType.EVENT_EXCEPTION: self.event_data = ExceptionEventData( ExceptionCode=event_data[0], ExceptionFlags=event_data[1], ExceptionRecord=event_data[2], ExceptionAddress=event_data[3], NumberParameters=event_data[4], ExceptionInformation=event_data[5], dwFirstChance=event_data[6] ) else: raise ValueError(f\"Unknown event type: {event_type}\")","title":"DbgEvent"},{"location":"api/debug-control/#x64dbg_automate.events.EventType","text":"Source code in x64dbg_automate\\events.py class EventType(StrEnum): EVENT_BREAKPOINT = \"EVENT_BREAKPOINT\" EVENT_SYSTEMBREAKPOINT = \"EVENT_SYSTEMBREAKPOINT\" EVENT_CREATE_THREAD = \"EVENT_CREATE_THREAD\" EVENT_EXIT_THREAD = \"EVENT_EXIT_THREAD\" EVENT_LOAD_DLL = \"EVENT_LOAD_DLL\" EVENT_UNLOAD_DLL = \"EVENT_UNLOAD_DLL\" EVENT_OUTPUT_DEBUG_STRING = \"EVENT_OUTPUT_DEBUG_STRING\" EVENT_EXCEPTION = \"EVENT_EXCEPTION\"","title":"EventType"},{"location":"api/gui/","text":"GUI Control User interface control is largely unimplemented at this point. API Method Reference gui_refresh_views() Refreshes the GUI views of x64dbg Returns: Type Description bool Success Source code in x64dbg_automate\\commands_xauto.py def gui_refresh_views(self) -> bool: \"\"\" Refreshes the GUI views of x64dbg Returns: Success \"\"\" return self._send_request(XAutoCommand.XAUTO_REQ_GUI_REFRESH_VIEWS)","title":"Gui"},{"location":"api/gui/#gui-control","text":"User interface control is largely unimplemented at this point.","title":"GUI Control"},{"location":"api/gui/#api-method-reference","text":"","title":"API Method Reference"},{"location":"api/gui/#x64dbg_automate.X64DbgClient.gui_refresh_views","text":"Refreshes the GUI views of x64dbg Returns: Type Description bool Success Source code in x64dbg_automate\\commands_xauto.py def gui_refresh_views(self) -> bool: \"\"\" Refreshes the GUI views of x64dbg Returns: Success \"\"\" return self._send_request(XAutoCommand.XAUTO_REQ_GUI_REFRESH_VIEWS)","title":"gui_refresh_views"},{"location":"api/memory-control/","text":"Memory Control What is Memory Control? Memory control refers to reading, writing, inspecting, allocating, freeing, and protecting memory. Example: Memory Control \"\"\" Example: Memory Control (64 bit) \"\"\" import queue import sys from x64dbg_automate import X64DbgClient from x64dbg_automate.events import DbgEvent, EventType from x64dbg_automate.models import MemPage, PageRightsConfiguration if len(sys.argv) != 2: print(\"Usage: python hello64.py <x64dbg_path>\") quit(1) print('[+] Creating a new x64dbg Automate session') client = X64DbgClient(x64dbg_path=sys.argv[1]) client.start_session(r'c:\\Windows\\system32\\winver.exe') client.go() # Continue from system breakpoint client.wait_until_stopped() client.go() # Continue from entrypoint print('[+] Registering a callback for debug string events') received: queue.Queue[DbgEvent] = queue.Queue() callback = lambda x: received.put(x) client.watch_debug_event(EventType.EVENT_OUTPUT_DEBUG_STRING, callback) print('[+] Allocating memory for shellcode and debug string') shellcode = client.virt_alloc() debug_string = client.virt_alloc() print('[+] Retrieving memory protection on debug string memory') mem: MemPage = client.virt_query(debug_string) print(f'\\tMemory Protection: 0x{mem.allocation_protect:X}') print('[+] Setting memory protection on debug string memory to readonly') client.virt_protect(debug_string, PageRightsConfiguration.ReadOnly) print('[+] Writing debug string to debugee memory') client.write_memory(debug_string, b'https://www.youtube.com/watch?v=FKROYzWRiQ0') print('[+] Writing shellcode to debugee memory') i = shellcode i = i + client.assemble_at(i, 'push rcx') i = i + client.assemble_at(i, 'push rcx') i = i + client.assemble_at(i, 'push rcx') i = i + client.assemble_at(i, 'mov rax, OutputDebugStringA') i = i + client.assemble_at(i, 'call rax') i = i + client.assemble_at(i, 'pop rcx') i = i + client.assemble_at(i, 'pop rcx') i = i + client.assemble_at(i, 'pop rcx') i = i + client.assemble_at(i, 'ret') print('[+] Executing shellcode') client.thread_create(shellcode, debug_string) ev = received.get(timeout=4) print('[+] Received debug string event') print('\\tEvent Type:', ev.event_type) print('\\tlpDebugStringData:', ev.event_data.lpDebugStringData.decode('utf-8').strip('\\0')) print('[+] Freeing memory') client.virt_free(shellcode) client.virt_free(debug_string) print('[+] Retrieving full memory map and finding all *.DLL references') pages: list[MemPage] = client.memmap() for page in pages: if '.dll' in page.info.lower(): print(f'\\t{page.allocation_base:X} - {page.region_size:X} {page.protect} {page.info}') print('[+] Terminating the session') client.terminate_session() [+] Creating a new x64dbg Automate session [+] Registering a callback for debug string events [+] Allocating memory for shellcode and debug string [+] Retrieving memory protection on debug string memory Memory Protection: 0x40 [+] Setting memory protection on debug string memory to readonly [+] Writing debug string to debugee memory [+] Writing shellcode to debugee memory [+] Executing shellcode [+] Received debug string event Event Type: EVENT_OUTPUT_DEBUG_STRING lpDebugStringData: https://www.youtube.com/watch?v=FKROYzWRiQ0 [+] Freeing memory [+] Retrieving full memory map and finding all *.DLL references 13B701B0000 - 63000 2 \\Device\\HarddiskVolume3\\Windows\\System32\\en-US\\shell32.dll.mui 13B70250000 - 3000 2 \\Device\\HarddiskVolume3\\Windows\\WinSxS\\amd64_microsoft.windows.c..-controls.resources_6595b64144ccf1df_6.0.26100.1591_en-us_541af4fe0fd3faf0\\comctl32.dll.mui 13B70270000 - 3000 2 \\Device\\HarddiskVolume3\\Windows\\System32\\oleaccrc.dll 7FFC726F0000 - 1000 2 oleacc.dll 7FFC77140000 - 1000 2 comctl32.dll 7FFC80AD0000 - 1000 2 textshaping.dll 7FFC82A30000 - 1000 2 textinputframework.dll 7FFC84210000 - 1000 2 winbrand.dll 7FFC8DA80000 - 1000 2 coreuicomponents.dll 7FFC903D0000 - 1000 2 coremessaging.dll 7FFC910D0000 - 1000 2 wintypes.dll 7FFC92380000 - 1000 2 uxtheme.dll 7FFC93F10000 - 1000 2 kernel.appcore.dll 7FFC94620000 - 1000 2 cryptbase.dll 7FFC95290000 - 1000 2 ucrtbase.dll 7FFC95470000 - 1000 2 gdi32full.dll 7FFC955A0000 - 1000 2 win32u.dll 7FFC955D0000 - 1000 2 kernelbase.dll 7FFC95990000 - 1000 2 msvcp_win.dll 7FFC95A40000 - 1000 2 bcryptprimitives.dll 7FFC95D40000 - 1000 2 shcore.dll 7FFC95E30000 - 1000 2 gdi32.dll 7FFC95FD0000 - 1000 2 user32.dll 7FFC96260000 - 1000 2 combase.dll 7FFC96A80000 - 1000 2 oleaut32.dll 7FFC96BB0000 - 1000 2 shell32.dll 7FFC972C0000 - 1000 2 advapi32.dll 7FFC97380000 - 1000 2 kernel32.dll 7FFC97450000 - 1000 2 msctf.dll 7FFC975B0000 - 1000 2 sechost.dll 7FFC976D0000 - 1000 2 shlwapi.dll 7FFC97730000 - 1000 2 clbcatq.dll 7FFC97860000 - 1000 2 msvcrt.dll 7FFC97930000 - 1000 2 imm32.dll 7FFC97970000 - 1000 2 rpcrt4.dll 7FFC97D40000 - 1000 2 ntdll.dll [+] Terminating the session API Method Reference write_memory(addr, data) Writes data to the debugee's memory Parameters: Name Type Description Default addr int The address to write to required data bytes The data to be written required Returns: Type Description bool Success Source code in x64dbg_automate\\commands_xauto.py def write_memory(self, addr: int, data: bytes) -> bool: \"\"\" Writes data to the debugee's memory Args: addr: The address to write to data: The data to be written Returns: Success \"\"\" return self._send_request(XAutoCommand.XAUTO_REQ_DBG_WRITE_MEMORY, addr, data) read_memory(addr, size) Reads data frpm the debugee's memory Parameters: Name Type Description Default addr int The address to read from required size int The number of bytes to read required Returns: Type Description bytes Success Source code in x64dbg_automate\\commands_xauto.py def read_memory(self, addr: int, size: int) -> bytes: \"\"\" Reads data frpm the debugee's memory Args: addr: The address to read from size: The number of bytes to read Returns: Success \"\"\" return self._send_request(XAutoCommand.XAUTO_REQ_DBG_READ_MEMORY, addr, size) memmap() Retrieves the memory map of the debugee Returns: Type Description list [ MemPage ] A list of MemPage objects Source code in x64dbg_automate\\commands_xauto.py def memmap(self) -> list[MemPage]: \"\"\" Retrieves the memory map of the debugee Returns: A list of MemPage objects \"\"\" resp = self._send_request(XAutoCommand.XAUTO_REQ_DBG_MEMMAP) pages = [] for page in resp: pages.append(MemPage(**{k: v for k, v in zip(MemPage.model_fields.keys(), page)})) return pages virt_alloc(n=4096, addr=0) Allocates memory in the debugee's address space Parameters: Name Type Description Default n int Size of memory to allocate 4096 addr int Address to allocate memory at 0 Returns: Type Description int Address of the allocated memory Source code in x64dbg_automate\\hla_xauto.py def virt_alloc(self, n: int = 0x1000, addr: int = 0) -> int: \"\"\" Allocates memory in the debugee's address space Args: n: Size of memory to allocate addr: Address to allocate memory at Returns: Address of the allocated memory \"\"\" if not self.cmd_sync(f\"alloc 0x{n:x}, 0x{addr:x}\"): raise ValueError(\"Failed to allocate memory\") addr, success = self.eval_sync(\"$result\") if not success: raise ValueError(\"Failed to evaluate result\") return addr virt_protect(addr, page_rights, guard=False) Changes a pages memory protection in the debugee's address space, optionally setting a page guard. Parameters: Name Type Description Default addr int Address to operate on required page_rights PageRightsConfiguration New memory protection configuration required guard bool page guard toggle False Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def virt_protect(self, addr: int, page_rights: PageRightsConfiguration, guard: bool = False) -> bool: \"\"\" Changes a pages memory protection in the debugee's address space, optionally setting a page guard. Args: addr: Address to operate on page_rights: New memory protection configuration guard: page guard toggle Returns: Success \"\"\" rights_str = str(page_rights) if guard: rights_str = f'G{rights_str}' if not self.cmd_sync(f\"setpagerights 0x{addr:x}, {rights_str}\"): raise ValueError(\"Failed to set memory protection\") return True virt_query(addr) Retrieves information about a memory region. Parameters: Name Type Description Default addr int Address to query required Returns: Type Description MemPage | None MemPage on success, None on failure Source code in x64dbg_automate\\hla_xauto.py def virt_query(self, addr: int) -> MemPage | None: \"\"\" Retrieves information about a memory region. Args: addr: Address to query Returns: MemPage on success, None on failure \"\"\" map = self.memmap() for m in map: if m.base_address <= addr < m.base_address + m.region_size: return m return None virt_free(addr) Frees memory in the debugee's address space Parameters: Name Type Description Default addr int Address to free memory at required Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def virt_free(self, addr: int) -> bool: \"\"\" Frees memory in the debugee's address space Args: addr: Address to free memory at Returns: Success \"\"\" if not self.cmd_sync(f\"free 0x{addr:x}\"): raise ValueError(\"Failed to free memory\") return True memset(addr, byte_val, size) Sets memory in the debugee's address space to the specified value Parameters: Name Type Description Default addr int Address to set memory at required byte_val int Value to set memory to required size int Number of bytes to set required Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def memset(self, addr: int, byte_val: int, size: int) -> bool: \"\"\" Sets memory in the debugee's address space to the specified value Args: addr: Address to set memory at byte_val: Value to set memory to size: Number of bytes to set Returns: Success \"\"\" if not self.cmd_sync(f\"memset 0x{addr:x}, 0x{byte_val:x}, 0x{size:x}\"): raise ValueError(\"Failed to set memory\") return True check_valid_read_ptr(addr) Checks if the specified address is accessible read memory in the debugee Parameters: Name Type Description Default addr int The address to check required Returns: Type Description bool True if the address is valid, False otherwise Source code in x64dbg_automate\\commands_xauto.py def check_valid_read_ptr(self, addr: int) -> bool: \"\"\" Checks if the specified address is accessible read memory in the debugee Args: addr: The address to check Returns: True if the address is valid, False otherwise \"\"\" return self._send_request(XAutoCommand.XAUTO_REQ_DBG_IS_VALID_READ_PTR, addr) API Model Reference MemPage Source code in x64dbg_automate\\models.py class MemPage(BaseModel): base_address: int allocation_base: int allocation_protect: int partition_id: int region_size: int state: int protect: int type: int info: str PageRightsConfiguration Source code in x64dbg_automate\\models.py class PageRightsConfiguration(StrEnum): Execute = \"Execute\" ExecuteRead = \"ExecuteRead\" ExecuteReadWrite = \"ExecuteReadWrite\" ExecuteWriteCopy = \"ExecuteWriteCopy\" NoAccess = \"NoAccess\" ReadOnly = \"ReadOnly\" ReadWrite = \"ReadWrite\" WriteCopy = \"WriteCopy\"","title":"Memory Control"},{"location":"api/memory-control/#memory-control","text":"","title":"Memory Control"},{"location":"api/memory-control/#what-is-memory-control","text":"Memory control refers to reading, writing, inspecting, allocating, freeing, and protecting memory.","title":"What is Memory Control?"},{"location":"api/memory-control/#example-memory-control","text":"\"\"\" Example: Memory Control (64 bit) \"\"\" import queue import sys from x64dbg_automate import X64DbgClient from x64dbg_automate.events import DbgEvent, EventType from x64dbg_automate.models import MemPage, PageRightsConfiguration if len(sys.argv) != 2: print(\"Usage: python hello64.py <x64dbg_path>\") quit(1) print('[+] Creating a new x64dbg Automate session') client = X64DbgClient(x64dbg_path=sys.argv[1]) client.start_session(r'c:\\Windows\\system32\\winver.exe') client.go() # Continue from system breakpoint client.wait_until_stopped() client.go() # Continue from entrypoint print('[+] Registering a callback for debug string events') received: queue.Queue[DbgEvent] = queue.Queue() callback = lambda x: received.put(x) client.watch_debug_event(EventType.EVENT_OUTPUT_DEBUG_STRING, callback) print('[+] Allocating memory for shellcode and debug string') shellcode = client.virt_alloc() debug_string = client.virt_alloc() print('[+] Retrieving memory protection on debug string memory') mem: MemPage = client.virt_query(debug_string) print(f'\\tMemory Protection: 0x{mem.allocation_protect:X}') print('[+] Setting memory protection on debug string memory to readonly') client.virt_protect(debug_string, PageRightsConfiguration.ReadOnly) print('[+] Writing debug string to debugee memory') client.write_memory(debug_string, b'https://www.youtube.com/watch?v=FKROYzWRiQ0') print('[+] Writing shellcode to debugee memory') i = shellcode i = i + client.assemble_at(i, 'push rcx') i = i + client.assemble_at(i, 'push rcx') i = i + client.assemble_at(i, 'push rcx') i = i + client.assemble_at(i, 'mov rax, OutputDebugStringA') i = i + client.assemble_at(i, 'call rax') i = i + client.assemble_at(i, 'pop rcx') i = i + client.assemble_at(i, 'pop rcx') i = i + client.assemble_at(i, 'pop rcx') i = i + client.assemble_at(i, 'ret') print('[+] Executing shellcode') client.thread_create(shellcode, debug_string) ev = received.get(timeout=4) print('[+] Received debug string event') print('\\tEvent Type:', ev.event_type) print('\\tlpDebugStringData:', ev.event_data.lpDebugStringData.decode('utf-8').strip('\\0')) print('[+] Freeing memory') client.virt_free(shellcode) client.virt_free(debug_string) print('[+] Retrieving full memory map and finding all *.DLL references') pages: list[MemPage] = client.memmap() for page in pages: if '.dll' in page.info.lower(): print(f'\\t{page.allocation_base:X} - {page.region_size:X} {page.protect} {page.info}') print('[+] Terminating the session') client.terminate_session() [+] Creating a new x64dbg Automate session [+] Registering a callback for debug string events [+] Allocating memory for shellcode and debug string [+] Retrieving memory protection on debug string memory Memory Protection: 0x40 [+] Setting memory protection on debug string memory to readonly [+] Writing debug string to debugee memory [+] Writing shellcode to debugee memory [+] Executing shellcode [+] Received debug string event Event Type: EVENT_OUTPUT_DEBUG_STRING lpDebugStringData: https://www.youtube.com/watch?v=FKROYzWRiQ0 [+] Freeing memory [+] Retrieving full memory map and finding all *.DLL references 13B701B0000 - 63000 2 \\Device\\HarddiskVolume3\\Windows\\System32\\en-US\\shell32.dll.mui 13B70250000 - 3000 2 \\Device\\HarddiskVolume3\\Windows\\WinSxS\\amd64_microsoft.windows.c..-controls.resources_6595b64144ccf1df_6.0.26100.1591_en-us_541af4fe0fd3faf0\\comctl32.dll.mui 13B70270000 - 3000 2 \\Device\\HarddiskVolume3\\Windows\\System32\\oleaccrc.dll 7FFC726F0000 - 1000 2 oleacc.dll 7FFC77140000 - 1000 2 comctl32.dll 7FFC80AD0000 - 1000 2 textshaping.dll 7FFC82A30000 - 1000 2 textinputframework.dll 7FFC84210000 - 1000 2 winbrand.dll 7FFC8DA80000 - 1000 2 coreuicomponents.dll 7FFC903D0000 - 1000 2 coremessaging.dll 7FFC910D0000 - 1000 2 wintypes.dll 7FFC92380000 - 1000 2 uxtheme.dll 7FFC93F10000 - 1000 2 kernel.appcore.dll 7FFC94620000 - 1000 2 cryptbase.dll 7FFC95290000 - 1000 2 ucrtbase.dll 7FFC95470000 - 1000 2 gdi32full.dll 7FFC955A0000 - 1000 2 win32u.dll 7FFC955D0000 - 1000 2 kernelbase.dll 7FFC95990000 - 1000 2 msvcp_win.dll 7FFC95A40000 - 1000 2 bcryptprimitives.dll 7FFC95D40000 - 1000 2 shcore.dll 7FFC95E30000 - 1000 2 gdi32.dll 7FFC95FD0000 - 1000 2 user32.dll 7FFC96260000 - 1000 2 combase.dll 7FFC96A80000 - 1000 2 oleaut32.dll 7FFC96BB0000 - 1000 2 shell32.dll 7FFC972C0000 - 1000 2 advapi32.dll 7FFC97380000 - 1000 2 kernel32.dll 7FFC97450000 - 1000 2 msctf.dll 7FFC975B0000 - 1000 2 sechost.dll 7FFC976D0000 - 1000 2 shlwapi.dll 7FFC97730000 - 1000 2 clbcatq.dll 7FFC97860000 - 1000 2 msvcrt.dll 7FFC97930000 - 1000 2 imm32.dll 7FFC97970000 - 1000 2 rpcrt4.dll 7FFC97D40000 - 1000 2 ntdll.dll [+] Terminating the session","title":"Example: Memory Control"},{"location":"api/memory-control/#api-method-reference","text":"","title":"API Method Reference"},{"location":"api/memory-control/#x64dbg_automate.X64DbgClient.write_memory","text":"Writes data to the debugee's memory Parameters: Name Type Description Default addr int The address to write to required data bytes The data to be written required Returns: Type Description bool Success Source code in x64dbg_automate\\commands_xauto.py def write_memory(self, addr: int, data: bytes) -> bool: \"\"\" Writes data to the debugee's memory Args: addr: The address to write to data: The data to be written Returns: Success \"\"\" return self._send_request(XAutoCommand.XAUTO_REQ_DBG_WRITE_MEMORY, addr, data)","title":"write_memory"},{"location":"api/memory-control/#x64dbg_automate.X64DbgClient.read_memory","text":"Reads data frpm the debugee's memory Parameters: Name Type Description Default addr int The address to read from required size int The number of bytes to read required Returns: Type Description bytes Success Source code in x64dbg_automate\\commands_xauto.py def read_memory(self, addr: int, size: int) -> bytes: \"\"\" Reads data frpm the debugee's memory Args: addr: The address to read from size: The number of bytes to read Returns: Success \"\"\" return self._send_request(XAutoCommand.XAUTO_REQ_DBG_READ_MEMORY, addr, size)","title":"read_memory"},{"location":"api/memory-control/#x64dbg_automate.X64DbgClient.memmap","text":"Retrieves the memory map of the debugee Returns: Type Description list [ MemPage ] A list of MemPage objects Source code in x64dbg_automate\\commands_xauto.py def memmap(self) -> list[MemPage]: \"\"\" Retrieves the memory map of the debugee Returns: A list of MemPage objects \"\"\" resp = self._send_request(XAutoCommand.XAUTO_REQ_DBG_MEMMAP) pages = [] for page in resp: pages.append(MemPage(**{k: v for k, v in zip(MemPage.model_fields.keys(), page)})) return pages","title":"memmap"},{"location":"api/memory-control/#x64dbg_automate.X64DbgClient.virt_alloc","text":"Allocates memory in the debugee's address space Parameters: Name Type Description Default n int Size of memory to allocate 4096 addr int Address to allocate memory at 0 Returns: Type Description int Address of the allocated memory Source code in x64dbg_automate\\hla_xauto.py def virt_alloc(self, n: int = 0x1000, addr: int = 0) -> int: \"\"\" Allocates memory in the debugee's address space Args: n: Size of memory to allocate addr: Address to allocate memory at Returns: Address of the allocated memory \"\"\" if not self.cmd_sync(f\"alloc 0x{n:x}, 0x{addr:x}\"): raise ValueError(\"Failed to allocate memory\") addr, success = self.eval_sync(\"$result\") if not success: raise ValueError(\"Failed to evaluate result\") return addr","title":"virt_alloc"},{"location":"api/memory-control/#x64dbg_automate.X64DbgClient.virt_protect","text":"Changes a pages memory protection in the debugee's address space, optionally setting a page guard. Parameters: Name Type Description Default addr int Address to operate on required page_rights PageRightsConfiguration New memory protection configuration required guard bool page guard toggle False Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def virt_protect(self, addr: int, page_rights: PageRightsConfiguration, guard: bool = False) -> bool: \"\"\" Changes a pages memory protection in the debugee's address space, optionally setting a page guard. Args: addr: Address to operate on page_rights: New memory protection configuration guard: page guard toggle Returns: Success \"\"\" rights_str = str(page_rights) if guard: rights_str = f'G{rights_str}' if not self.cmd_sync(f\"setpagerights 0x{addr:x}, {rights_str}\"): raise ValueError(\"Failed to set memory protection\") return True","title":"virt_protect"},{"location":"api/memory-control/#x64dbg_automate.X64DbgClient.virt_query","text":"Retrieves information about a memory region. Parameters: Name Type Description Default addr int Address to query required Returns: Type Description MemPage | None MemPage on success, None on failure Source code in x64dbg_automate\\hla_xauto.py def virt_query(self, addr: int) -> MemPage | None: \"\"\" Retrieves information about a memory region. Args: addr: Address to query Returns: MemPage on success, None on failure \"\"\" map = self.memmap() for m in map: if m.base_address <= addr < m.base_address + m.region_size: return m return None","title":"virt_query"},{"location":"api/memory-control/#x64dbg_automate.X64DbgClient.virt_free","text":"Frees memory in the debugee's address space Parameters: Name Type Description Default addr int Address to free memory at required Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def virt_free(self, addr: int) -> bool: \"\"\" Frees memory in the debugee's address space Args: addr: Address to free memory at Returns: Success \"\"\" if not self.cmd_sync(f\"free 0x{addr:x}\"): raise ValueError(\"Failed to free memory\") return True","title":"virt_free"},{"location":"api/memory-control/#x64dbg_automate.X64DbgClient.memset","text":"Sets memory in the debugee's address space to the specified value Parameters: Name Type Description Default addr int Address to set memory at required byte_val int Value to set memory to required size int Number of bytes to set required Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def memset(self, addr: int, byte_val: int, size: int) -> bool: \"\"\" Sets memory in the debugee's address space to the specified value Args: addr: Address to set memory at byte_val: Value to set memory to size: Number of bytes to set Returns: Success \"\"\" if not self.cmd_sync(f\"memset 0x{addr:x}, 0x{byte_val:x}, 0x{size:x}\"): raise ValueError(\"Failed to set memory\") return True","title":"memset"},{"location":"api/memory-control/#x64dbg_automate.X64DbgClient.check_valid_read_ptr","text":"Checks if the specified address is accessible read memory in the debugee Parameters: Name Type Description Default addr int The address to check required Returns: Type Description bool True if the address is valid, False otherwise Source code in x64dbg_automate\\commands_xauto.py def check_valid_read_ptr(self, addr: int) -> bool: \"\"\" Checks if the specified address is accessible read memory in the debugee Args: addr: The address to check Returns: True if the address is valid, False otherwise \"\"\" return self._send_request(XAutoCommand.XAUTO_REQ_DBG_IS_VALID_READ_PTR, addr)","title":"check_valid_read_ptr"},{"location":"api/memory-control/#api-model-reference","text":"","title":"API Model Reference"},{"location":"api/memory-control/#x64dbg_automate.models.MemPage","text":"Source code in x64dbg_automate\\models.py class MemPage(BaseModel): base_address: int allocation_base: int allocation_protect: int partition_id: int region_size: int state: int protect: int type: int info: str","title":"MemPage"},{"location":"api/memory-control/#x64dbg_automate.models.PageRightsConfiguration","text":"Source code in x64dbg_automate\\models.py class PageRightsConfiguration(StrEnum): Execute = \"Execute\" ExecuteRead = \"ExecuteRead\" ExecuteReadWrite = \"ExecuteReadWrite\" ExecuteWriteCopy = \"ExecuteWriteCopy\" NoAccess = \"NoAccess\" ReadOnly = \"ReadOnly\" ReadWrite = \"ReadWrite\" WriteCopy = \"WriteCopy\"","title":"PageRightsConfiguration"},{"location":"api/registers-expressions/","text":"Registers and Expressions What is an Expression? An expression is a statement evaluated in the context of the debugger. It can be as simple as 2+2, or a complex calculation involving symbols, scales, and segments. x64dbg Automate provides the debugger's full evaluation capabilities, and adds some convenience methods. When you request a register in x64dbg Automate it's really just shorthand for evaluating an expression where the only value is your register. This is true unless a full register dump is requested. This is the exception to the above rule - instead providing a full thread context dump in the format the debugger uses internally. The full register dump can be useful for accessing more nuanced parts of thread state, but is generally overkill for common tasks like retrieving a common register value. Example: Expressions and Registers \"\"\" Example: Expressions and Registers (64 bit) \"\"\" import sys from x64dbg_automate import X64DbgClient from x64dbg_automate.models import RegDump64 if len(sys.argv) != 2: print(\"Usage: python hello64.py <x64dbg_path>\") quit(1) print('[+] Creating a new x64dbg Automate session') client = X64DbgClient(x64dbg_path=sys.argv[1]) client.start_session(r'c:\\Windows\\system32\\winver.exe') print('[+] Getting the value of RIP') rip = client.get_reg('rip') print(f'\\tRIP: 0x{rip:X}') print('[+] Setting the value of RIP') client.set_reg('rip', 0x1234) print('[+] Setting the value of RIP to an expression') value, _ = client.eval_sync('LoadLibraryA + 0x20') client.set_reg('rip', value) print('[+] Setting the value of a subregister') client.set_reg('rax', 0) client.set_reg('ah', 0x99) print('[+] Performing a full register dump') dump: RegDump64 = client.get_regs() print(f'\\tRIP: 0x{dump.context.rip:X}') print(f'\\tRAX: 0x{dump.context.rax:X}') print('[+] Cleaning up') client.terminate_session() [+] Creating a new x64dbg Automate session [+] Getting the value of RIP RIP: 0x7FFC97E6142A [+] Setting the value of RIP [+] Setting the value of RIP to an expression [+] Setting the value of a subregister [+] Performing a full register dump RIP: 0x7FFC973C2DA0 RAX: 0x9900 [+] Cleaning up API Method Reference get_reg(reg) Get a single register or subregister Returns: Type Description int Success Source code in x64dbg_automate\\hla_xauto.py def get_reg(self, reg: MutableRegister | str) -> int: \"\"\" Get a single register or subregister Returns: Success \"\"\" reg = MutableRegister(str(reg).lower()) res, success = self.eval_sync(f'{reg}') if not success: raise ValueError(f\"Failed to evaluate register {reg}\") return res get_regs() Dump the registers of the debugee Returns: Type Description list [ RegDump32 ] | list [ RegDump64 ] A list of RegDump objects Source code in x64dbg_automate\\commands_xauto.py def get_regs(self) -> list[RegDump32] | list[RegDump64]: \"\"\" Dump the registers of the debugee Returns: A list of RegDump objects \"\"\" raw_regs = self._send_request(XAutoCommand.XAUTO_REQ_DBG_READ_REGISTERS) bitness = raw_regs[0] raw_regs = raw_regs[1:] if bitness == 64: ctx = {k: v for k, v in zip(Context64.model_fields.keys(), raw_regs[0])} ctx['x87_fpu'] = X87Fpu(**{k: v for k, v in zip(X87Fpu.model_fields.keys(), ctx['x87_fpu'])}) ctx['xmm_regs'] = [ctx['xmm_regs'][i:i+16] for i in range(0, len(ctx['xmm_regs']), 16)] ctx['ymm_regs'] = [ctx['ymm_regs'][i:i+32] for i in range(0, len(ctx['ymm_regs']), 32)] return RegDump64( context=Context64(**ctx), flags=Flags(**{k: v for k, v in zip(Flags.model_fields.keys(), raw_regs[1])}), fpu=[FpuReg(data=raw_regs[2][i][0], st_value=raw_regs[2][i][1], tag=raw_regs[2][i][2]) for i in range(len(raw_regs[2]))], mmx=raw_regs[3], mxcsr_fields=MxcsrFields(**{k: v for k, v in zip(MxcsrFields.model_fields.keys(), raw_regs[4])}), x87_status_word_fields=X87StatusWordFields(**{k: v for k, v in zip(X87StatusWordFields.model_fields.keys(), raw_regs[5])}), x87_control_word_fields=X87ControlWordFields(**{k: v for k, v in zip(X87ControlWordFields.model_fields.keys(), raw_regs[6])}), last_error=(raw_regs[7][0], raw_regs[7][1].decode().strip('\\0')), last_status=(raw_regs[8][0], raw_regs[8][1].decode().strip('\\0')) ) else: ctx = {k: v for k, v in zip(Context32.model_fields.keys(), raw_regs[0])} ctx['x87_fpu'] = X87Fpu(**{k: v for k, v in zip(X87Fpu.model_fields.keys(), ctx['x87_fpu'])}) ctx['xmm_regs'] = [ctx['xmm_regs'][i:i+16] for i in range(0, len(ctx['xmm_regs']), 16)] ctx['ymm_regs'] = [ctx['ymm_regs'][i:i+32] for i in range(0, len(ctx['ymm_regs']), 32)] return RegDump32( context=Context32(**ctx), flags=Flags(**{k: v for k, v in zip(Flags.model_fields.keys(), raw_regs[1])}), fpu=[FpuReg(data=raw_regs[2][i][0], st_value=raw_regs[2][i][1], tag=raw_regs[2][i][2]) for i in range(len(raw_regs[2]))], mmx=raw_regs[3], mxcsr_fields=MxcsrFields(**{k: v for k, v in zip(MxcsrFields.model_fields.keys(), raw_regs[4])}), x87_status_word_fields=X87StatusWordFields(**{k: v for k, v in zip(X87StatusWordFields.model_fields.keys(), raw_regs[5])}), x87_control_word_fields=X87ControlWordFields(**{k: v for k, v in zip(X87ControlWordFields.model_fields.keys(), raw_regs[6])}), last_error=(raw_regs[7][0], raw_regs[7][1]), last_status=(raw_regs[8][0], raw_regs[8][1]) ) set_reg(reg, val) Set a single register or subregister to a value Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def set_reg(self, reg: MutableRegister | str, val: int) -> bool: \"\"\" Set a single register or subregister to a value Returns: Success \"\"\" reg = MutableRegister(str(reg).lower()) if not isinstance(val, int): raise TypeError(\"val must be an integer\") return self.cmd_sync(f'{reg}=0x{val:X}') eval_sync(eval_str) Evaluates an expression that results in a numerical output Returns: Type Description list [ int , bool ] A list containing the result and a boolean indicating success Source code in x64dbg_automate\\commands_xauto.py def eval_sync(self, eval_str) -> list[int, bool]: \"\"\" Evaluates an expression that results in a numerical output Returns: A list containing the result and a boolean indicating success \"\"\" return self._send_request(XAutoCommand.XAUTO_REQ_DBG_EVAL, eval_str) get_symbol_at(addr) Retrieves the symbol at the specified address Parameters: Name Type Description Default addr int The address to get the symbol for required Returns: Type Description Symbol | None A Symbol object or None if no symbol was found Source code in x64dbg_automate\\commands_xauto.py def get_symbol_at(self, addr: int) -> Symbol | None: \"\"\" Retrieves the symbol at the specified address Args: addr: The address to get the symbol for Returns: A Symbol object or None if no symbol was found \"\"\" res = self._send_request(XAutoCommand.XAUTO_REQ_GET_SYMBOL, addr) if not res[0]: return \"\" return Symbol( addr=res[1], decoratedSymbol=res[2], undecoratedSymbol=res[3], type=SymbolType(res[4]), ordinal=res[5] ) API Model Reference RegDump Bases: BaseModel Source code in x64dbg_automate\\models.py class RegDump(BaseModel): flags: Flags fpu: list[FpuReg] mmx: list[int] mxcsr_fields: MxcsrFields x87_status_word_fields: X87StatusWordFields x87_control_word_fields: X87ControlWordFields last_error: tuple[int, str] last_status: tuple[int, str] RegDump64 Bases: RegDump Source code in x64dbg_automate\\models.py class RegDump64(RegDump): context: Context64 RegDump32 Bases: RegDump Source code in x64dbg_automate\\models.py class RegDump32(RegDump): context: Context32 Context64 Bases: BaseModel Source code in x64dbg_automate\\models.py class Context64(BaseModel): rax: int rbx: int rcx: int rdx: int rbp: int rsp: int rsi: int rdi: int r8: int r9: int r10: int r11: int r12: int r13: int r14: int r15: int rip: int eflags: int cs: int ds: int es: int fs: int gs: int ss: int dr0: int dr1: int dr2: int dr3: int dr6: int dr7: int reg_area: bytes x87_fpu: X87Fpu mxcsr: int xmm_regs: list[bytes] ymm_regs: list[bytes] Context32 Bases: BaseModel Source code in x64dbg_automate\\models.py class Context32(BaseModel): eax: int ebx: int ecx: int edx: int ebp: int esp: int esi: int edi: int eip: int eflags: int cs: int ds: int es: int fs: int gs: int ss: int dr0: int dr1: int dr2: int dr3: int dr6: int dr7: int reg_area: bytes x87_fpu: X87Fpu mxcsr: int xmm_regs: list[bytes] ymm_regs: list[bytes] X87Fpu Bases: BaseModel Source code in x64dbg_automate\\models.py class X87Fpu(BaseModel): ControlWord: int StatusWord: int TagWord: int ErrorOffset: int ErrorSelector: int DataOffset: int DataSelector: int Cr0NpxState: int Flags Bases: BaseModel Source code in x64dbg_automate\\models.py class Flags(BaseModel): c: bool p: bool a: bool z: bool s: bool t: bool i: bool d: bool o: bool FpuReg Bases: BaseModel Source code in x64dbg_automate\\models.py class FpuReg(BaseModel): data: bytes st_value: int tag: int MxcsrFields Bases: BaseModel Source code in x64dbg_automate\\models.py class MxcsrFields(BaseModel): FZ: bool PM: bool UM: bool OM: bool ZM: bool IM: bool DM: bool DAZ: bool PE: bool UE: bool OE: bool ZE: bool DE: bool IE: bool RC: int X87StatusWordFields Bases: BaseModel Source code in x64dbg_automate\\models.py class X87StatusWordFields(BaseModel): B: bool C3: bool C2: bool C1: bool C0: bool ES: bool SF: bool P: bool U: bool O: bool Z: bool D: bool I: bool TOP: int X87ControlWordFields Bases: BaseModel Source code in x64dbg_automate\\models.py class X87ControlWordFields(BaseModel): IC: bool IEM: bool PM: bool UM: bool OM: bool ZM: bool DM: bool IM: bool RC: int PC: int Symbol Bases: BaseModel Source code in x64dbg_automate\\models.py class Symbol(BaseModel): addr: int decoratedSymbol: str undecoratedSymbol: str type: int ordinal: int SymbolType Bases: IntEnum Source code in x64dbg_automate\\models.py class SymbolType(IntEnum): SymImport = 0 SymExport = 1 SymSymbol = 2 MutableRegister Bases: StrEnum Source code in x64dbg_automate\\models.py class MutableRegister(StrEnum): rax = 'rax' rbx = 'rbx' rcx = 'rcx' rdx = 'rdx' rbp = 'rbp' rsp = 'rsp' rsi = 'rsi' rdi = 'rdi' r8 = 'r8' r9 = 'r9' r10 = 'r10' r11 = 'r11' r12 = 'r12' r13 = 'r13' r14 = 'r14' r15 = 'r15' rip = 'rip' eip = 'eip' eflags = 'eflags' rflags = 'rflags' cs = 'cs' ds = 'ds' es = 'es' fs = 'fs' gs = 'gs' ss = 'ss' dr0 = 'dr0' dr1 = 'dr1' dr2 = 'dr2' dr3 = 'dr3' dr6 = 'dr6' dr7 = 'dr7' eax = 'eax' ebx = 'ebx' ecx = 'ecx' edx = 'edx' ebp = 'ebp' esp = 'esp' esi = 'esi' edi = 'edi' ax = 'ax' bx = 'bx' cx = 'cx' dx = 'dx' si = 'si' di = 'di' bp = 'bp' sp = 'sp' al = 'al' bl = 'bl' cl = 'cl' dl = 'dl' ah = 'ah' bh = 'bh' ch = 'ch' dh = 'dh' sil = 'sil' dil = 'dil' bpl = 'bpl' spl = 'spl' r8d = 'r8d' r9d = 'r9d' r10d = 'r10d' r11d = 'r11d' r12d = 'r12d' r13d = 'r13d' r14d = 'r14d' r15d = 'r15d' r8w = 'r8w' r9w = 'r9w' r10w = 'r10w' r11w = 'r11w' r12w = 'r12w' r13w = 'r13w' r14w = 'r14w' r15w = 'r15w' r8b = 'r8b' r9b = 'r9b' r10b = 'r10b' r11b = 'r11b' r12b = 'r12b' r13b = 'r13b' r14b = 'r14b' r15b = 'r15b'","title":"Registers and Expressions"},{"location":"api/registers-expressions/#registers-and-expressions","text":"","title":"Registers and Expressions"},{"location":"api/registers-expressions/#what-is-an-expression","text":"An expression is a statement evaluated in the context of the debugger. It can be as simple as 2+2, or a complex calculation involving symbols, scales, and segments. x64dbg Automate provides the debugger's full evaluation capabilities, and adds some convenience methods. When you request a register in x64dbg Automate it's really just shorthand for evaluating an expression where the only value is your register. This is true unless a full register dump is requested. This is the exception to the above rule - instead providing a full thread context dump in the format the debugger uses internally. The full register dump can be useful for accessing more nuanced parts of thread state, but is generally overkill for common tasks like retrieving a common register value.","title":"What is an Expression?"},{"location":"api/registers-expressions/#example-expressions-and-registers","text":"\"\"\" Example: Expressions and Registers (64 bit) \"\"\" import sys from x64dbg_automate import X64DbgClient from x64dbg_automate.models import RegDump64 if len(sys.argv) != 2: print(\"Usage: python hello64.py <x64dbg_path>\") quit(1) print('[+] Creating a new x64dbg Automate session') client = X64DbgClient(x64dbg_path=sys.argv[1]) client.start_session(r'c:\\Windows\\system32\\winver.exe') print('[+] Getting the value of RIP') rip = client.get_reg('rip') print(f'\\tRIP: 0x{rip:X}') print('[+] Setting the value of RIP') client.set_reg('rip', 0x1234) print('[+] Setting the value of RIP to an expression') value, _ = client.eval_sync('LoadLibraryA + 0x20') client.set_reg('rip', value) print('[+] Setting the value of a subregister') client.set_reg('rax', 0) client.set_reg('ah', 0x99) print('[+] Performing a full register dump') dump: RegDump64 = client.get_regs() print(f'\\tRIP: 0x{dump.context.rip:X}') print(f'\\tRAX: 0x{dump.context.rax:X}') print('[+] Cleaning up') client.terminate_session() [+] Creating a new x64dbg Automate session [+] Getting the value of RIP RIP: 0x7FFC97E6142A [+] Setting the value of RIP [+] Setting the value of RIP to an expression [+] Setting the value of a subregister [+] Performing a full register dump RIP: 0x7FFC973C2DA0 RAX: 0x9900 [+] Cleaning up","title":"Example: Expressions and Registers"},{"location":"api/registers-expressions/#api-method-reference","text":"","title":"API Method Reference"},{"location":"api/registers-expressions/#x64dbg_automate.X64DbgClient.get_reg","text":"Get a single register or subregister Returns: Type Description int Success Source code in x64dbg_automate\\hla_xauto.py def get_reg(self, reg: MutableRegister | str) -> int: \"\"\" Get a single register or subregister Returns: Success \"\"\" reg = MutableRegister(str(reg).lower()) res, success = self.eval_sync(f'{reg}') if not success: raise ValueError(f\"Failed to evaluate register {reg}\") return res","title":"get_reg"},{"location":"api/registers-expressions/#x64dbg_automate.X64DbgClient.get_regs","text":"Dump the registers of the debugee Returns: Type Description list [ RegDump32 ] | list [ RegDump64 ] A list of RegDump objects Source code in x64dbg_automate\\commands_xauto.py def get_regs(self) -> list[RegDump32] | list[RegDump64]: \"\"\" Dump the registers of the debugee Returns: A list of RegDump objects \"\"\" raw_regs = self._send_request(XAutoCommand.XAUTO_REQ_DBG_READ_REGISTERS) bitness = raw_regs[0] raw_regs = raw_regs[1:] if bitness == 64: ctx = {k: v for k, v in zip(Context64.model_fields.keys(), raw_regs[0])} ctx['x87_fpu'] = X87Fpu(**{k: v for k, v in zip(X87Fpu.model_fields.keys(), ctx['x87_fpu'])}) ctx['xmm_regs'] = [ctx['xmm_regs'][i:i+16] for i in range(0, len(ctx['xmm_regs']), 16)] ctx['ymm_regs'] = [ctx['ymm_regs'][i:i+32] for i in range(0, len(ctx['ymm_regs']), 32)] return RegDump64( context=Context64(**ctx), flags=Flags(**{k: v for k, v in zip(Flags.model_fields.keys(), raw_regs[1])}), fpu=[FpuReg(data=raw_regs[2][i][0], st_value=raw_regs[2][i][1], tag=raw_regs[2][i][2]) for i in range(len(raw_regs[2]))], mmx=raw_regs[3], mxcsr_fields=MxcsrFields(**{k: v for k, v in zip(MxcsrFields.model_fields.keys(), raw_regs[4])}), x87_status_word_fields=X87StatusWordFields(**{k: v for k, v in zip(X87StatusWordFields.model_fields.keys(), raw_regs[5])}), x87_control_word_fields=X87ControlWordFields(**{k: v for k, v in zip(X87ControlWordFields.model_fields.keys(), raw_regs[6])}), last_error=(raw_regs[7][0], raw_regs[7][1].decode().strip('\\0')), last_status=(raw_regs[8][0], raw_regs[8][1].decode().strip('\\0')) ) else: ctx = {k: v for k, v in zip(Context32.model_fields.keys(), raw_regs[0])} ctx['x87_fpu'] = X87Fpu(**{k: v for k, v in zip(X87Fpu.model_fields.keys(), ctx['x87_fpu'])}) ctx['xmm_regs'] = [ctx['xmm_regs'][i:i+16] for i in range(0, len(ctx['xmm_regs']), 16)] ctx['ymm_regs'] = [ctx['ymm_regs'][i:i+32] for i in range(0, len(ctx['ymm_regs']), 32)] return RegDump32( context=Context32(**ctx), flags=Flags(**{k: v for k, v in zip(Flags.model_fields.keys(), raw_regs[1])}), fpu=[FpuReg(data=raw_regs[2][i][0], st_value=raw_regs[2][i][1], tag=raw_regs[2][i][2]) for i in range(len(raw_regs[2]))], mmx=raw_regs[3], mxcsr_fields=MxcsrFields(**{k: v for k, v in zip(MxcsrFields.model_fields.keys(), raw_regs[4])}), x87_status_word_fields=X87StatusWordFields(**{k: v for k, v in zip(X87StatusWordFields.model_fields.keys(), raw_regs[5])}), x87_control_word_fields=X87ControlWordFields(**{k: v for k, v in zip(X87ControlWordFields.model_fields.keys(), raw_regs[6])}), last_error=(raw_regs[7][0], raw_regs[7][1]), last_status=(raw_regs[8][0], raw_regs[8][1]) )","title":"get_regs"},{"location":"api/registers-expressions/#x64dbg_automate.X64DbgClient.set_reg","text":"Set a single register or subregister to a value Returns: Type Description bool Success Source code in x64dbg_automate\\hla_xauto.py def set_reg(self, reg: MutableRegister | str, val: int) -> bool: \"\"\" Set a single register or subregister to a value Returns: Success \"\"\" reg = MutableRegister(str(reg).lower()) if not isinstance(val, int): raise TypeError(\"val must be an integer\") return self.cmd_sync(f'{reg}=0x{val:X}')","title":"set_reg"},{"location":"api/registers-expressions/#x64dbg_automate.X64DbgClient.eval_sync","text":"Evaluates an expression that results in a numerical output Returns: Type Description list [ int , bool ] A list containing the result and a boolean indicating success Source code in x64dbg_automate\\commands_xauto.py def eval_sync(self, eval_str) -> list[int, bool]: \"\"\" Evaluates an expression that results in a numerical output Returns: A list containing the result and a boolean indicating success \"\"\" return self._send_request(XAutoCommand.XAUTO_REQ_DBG_EVAL, eval_str)","title":"eval_sync"},{"location":"api/registers-expressions/#x64dbg_automate.X64DbgClient.get_symbol_at","text":"Retrieves the symbol at the specified address Parameters: Name Type Description Default addr int The address to get the symbol for required Returns: Type Description Symbol | None A Symbol object or None if no symbol was found Source code in x64dbg_automate\\commands_xauto.py def get_symbol_at(self, addr: int) -> Symbol | None: \"\"\" Retrieves the symbol at the specified address Args: addr: The address to get the symbol for Returns: A Symbol object or None if no symbol was found \"\"\" res = self._send_request(XAutoCommand.XAUTO_REQ_GET_SYMBOL, addr) if not res[0]: return \"\" return Symbol( addr=res[1], decoratedSymbol=res[2], undecoratedSymbol=res[3], type=SymbolType(res[4]), ordinal=res[5] )","title":"get_symbol_at"},{"location":"api/registers-expressions/#api-model-reference","text":"","title":"API Model Reference"},{"location":"api/registers-expressions/#x64dbg_automate.models.RegDump","text":"Bases: BaseModel Source code in x64dbg_automate\\models.py class RegDump(BaseModel): flags: Flags fpu: list[FpuReg] mmx: list[int] mxcsr_fields: MxcsrFields x87_status_word_fields: X87StatusWordFields x87_control_word_fields: X87ControlWordFields last_error: tuple[int, str] last_status: tuple[int, str]","title":"RegDump"},{"location":"api/registers-expressions/#x64dbg_automate.models.RegDump64","text":"Bases: RegDump Source code in x64dbg_automate\\models.py class RegDump64(RegDump): context: Context64","title":"RegDump64"},{"location":"api/registers-expressions/#x64dbg_automate.models.RegDump32","text":"Bases: RegDump Source code in x64dbg_automate\\models.py class RegDump32(RegDump): context: Context32","title":"RegDump32"},{"location":"api/registers-expressions/#x64dbg_automate.models.Context64","text":"Bases: BaseModel Source code in x64dbg_automate\\models.py class Context64(BaseModel): rax: int rbx: int rcx: int rdx: int rbp: int rsp: int rsi: int rdi: int r8: int r9: int r10: int r11: int r12: int r13: int r14: int r15: int rip: int eflags: int cs: int ds: int es: int fs: int gs: int ss: int dr0: int dr1: int dr2: int dr3: int dr6: int dr7: int reg_area: bytes x87_fpu: X87Fpu mxcsr: int xmm_regs: list[bytes] ymm_regs: list[bytes]","title":"Context64"},{"location":"api/registers-expressions/#x64dbg_automate.models.Context32","text":"Bases: BaseModel Source code in x64dbg_automate\\models.py class Context32(BaseModel): eax: int ebx: int ecx: int edx: int ebp: int esp: int esi: int edi: int eip: int eflags: int cs: int ds: int es: int fs: int gs: int ss: int dr0: int dr1: int dr2: int dr3: int dr6: int dr7: int reg_area: bytes x87_fpu: X87Fpu mxcsr: int xmm_regs: list[bytes] ymm_regs: list[bytes]","title":"Context32"},{"location":"api/registers-expressions/#x64dbg_automate.models.X87Fpu","text":"Bases: BaseModel Source code in x64dbg_automate\\models.py class X87Fpu(BaseModel): ControlWord: int StatusWord: int TagWord: int ErrorOffset: int ErrorSelector: int DataOffset: int DataSelector: int Cr0NpxState: int","title":"X87Fpu"},{"location":"api/registers-expressions/#x64dbg_automate.models.Flags","text":"Bases: BaseModel Source code in x64dbg_automate\\models.py class Flags(BaseModel): c: bool p: bool a: bool z: bool s: bool t: bool i: bool d: bool o: bool","title":"Flags"},{"location":"api/registers-expressions/#x64dbg_automate.models.FpuReg","text":"Bases: BaseModel Source code in x64dbg_automate\\models.py class FpuReg(BaseModel): data: bytes st_value: int tag: int","title":"FpuReg"},{"location":"api/registers-expressions/#x64dbg_automate.models.MxcsrFields","text":"Bases: BaseModel Source code in x64dbg_automate\\models.py class MxcsrFields(BaseModel): FZ: bool PM: bool UM: bool OM: bool ZM: bool IM: bool DM: bool DAZ: bool PE: bool UE: bool OE: bool ZE: bool DE: bool IE: bool RC: int","title":"MxcsrFields"},{"location":"api/registers-expressions/#x64dbg_automate.models.X87StatusWordFields","text":"Bases: BaseModel Source code in x64dbg_automate\\models.py class X87StatusWordFields(BaseModel): B: bool C3: bool C2: bool C1: bool C0: bool ES: bool SF: bool P: bool U: bool O: bool Z: bool D: bool I: bool TOP: int","title":"X87StatusWordFields"},{"location":"api/registers-expressions/#x64dbg_automate.models.X87ControlWordFields","text":"Bases: BaseModel Source code in x64dbg_automate\\models.py class X87ControlWordFields(BaseModel): IC: bool IEM: bool PM: bool UM: bool OM: bool ZM: bool DM: bool IM: bool RC: int PC: int","title":"X87ControlWordFields"},{"location":"api/registers-expressions/#x64dbg_automate.models.Symbol","text":"Bases: BaseModel Source code in x64dbg_automate\\models.py class Symbol(BaseModel): addr: int decoratedSymbol: str undecoratedSymbol: str type: int ordinal: int","title":"Symbol"},{"location":"api/registers-expressions/#x64dbg_automate.models.SymbolType","text":"Bases: IntEnum Source code in x64dbg_automate\\models.py class SymbolType(IntEnum): SymImport = 0 SymExport = 1 SymSymbol = 2","title":"SymbolType"},{"location":"api/registers-expressions/#x64dbg_automate.models.MutableRegister","text":"Bases: StrEnum Source code in x64dbg_automate\\models.py class MutableRegister(StrEnum): rax = 'rax' rbx = 'rbx' rcx = 'rcx' rdx = 'rdx' rbp = 'rbp' rsp = 'rsp' rsi = 'rsi' rdi = 'rdi' r8 = 'r8' r9 = 'r9' r10 = 'r10' r11 = 'r11' r12 = 'r12' r13 = 'r13' r14 = 'r14' r15 = 'r15' rip = 'rip' eip = 'eip' eflags = 'eflags' rflags = 'rflags' cs = 'cs' ds = 'ds' es = 'es' fs = 'fs' gs = 'gs' ss = 'ss' dr0 = 'dr0' dr1 = 'dr1' dr2 = 'dr2' dr3 = 'dr3' dr6 = 'dr6' dr7 = 'dr7' eax = 'eax' ebx = 'ebx' ecx = 'ecx' edx = 'edx' ebp = 'ebp' esp = 'esp' esi = 'esi' edi = 'edi' ax = 'ax' bx = 'bx' cx = 'cx' dx = 'dx' si = 'si' di = 'di' bp = 'bp' sp = 'sp' al = 'al' bl = 'bl' cl = 'cl' dl = 'dl' ah = 'ah' bh = 'bh' ch = 'ch' dh = 'dh' sil = 'sil' dil = 'dil' bpl = 'bpl' spl = 'spl' r8d = 'r8d' r9d = 'r9d' r10d = 'r10d' r11d = 'r11d' r12d = 'r12d' r13d = 'r13d' r14d = 'r14d' r15d = 'r15d' r8w = 'r8w' r9w = 'r9w' r10w = 'r10w' r11w = 'r11w' r12w = 'r12w' r13w = 'r13w' r14w = 'r14w' r15w = 'r15w' r8b = 'r8b' r9b = 'r9b' r10b = 'r10b' r11b = 'r11b' r12b = 'r12b' r13b = 'r13b' r14b = 'r14b' r15b = 'r15b'","title":"MutableRegister"},{"location":"api/session-control/","text":"Session Control What are Sessions? A session refers to an automation-enabled running instance of x64dbg. Each instance of the debugger you launch or attach to has a session ID allocated to it. The automation client relies on sessions to know which debugger instance to communicate with. For all intents and purposes the session ID is equivalent to the debugger PID. After launching x64dbg with the plugin installed its session ID and port binds can be seen in the startup log: [x64dbg-automate] Allocated session ID: 12584 [x64dbg-automate] Allocated PUB/SUB port: 49759 [x64dbg-automate] Allocated REQ/REP port: 52085 Sessions can also be discovered programmatically - with PIDs, command lines, working directories, and window titles provided for disambiguation. Example: Sessions \"\"\" Example: Session Control (32/64 bit) \"\"\" import subprocess import sys from x64dbg_automate import X64DbgClient if len(sys.argv) != 2: print(\"Usage: python sessions.py <x64dbg_path>\") quit(1) print('[+] Creating an x64dbg Automate session using start_session') client1 = X64DbgClient(x64dbg_path=sys.argv[1]) client1.start_session(r'c:\\Windows\\system32\\winver.exe') print('[+] Starting an unconnected session using subprocess.Popen') client2 = X64DbgClient(x64dbg_path=sys.argv[1]) proc = subprocess.Popen([sys.argv[1]], executable=sys.argv[1]) print('[+] Waiting for the unconnected session to start') X64DbgClient.wait_for_session(proc.pid) print('[+] Listing running sessions') sessions = X64DbgClient.list_sessions() print(sessions) print('[+] Terminating the first session') client1.terminate_session() print('[+] Listing running sessions') sessions = X64DbgClient.list_sessions() print(sessions) print('[+] Attaching to the second session') client2.attach_session(sessions[0].pid) print('[+] Detaching from the second session') client2.detach_session() print('[+] Re-attaching to the second session') client2.attach_session(sessions[0].pid) print('[+] Terminating the second session') client2.terminate_session() [+] Creating an x64dbg Automate session using start_session [+] Starting an unconnected session using subprocess.Popen [+] Waiting for the unconnected session to start [+] Listing running sessions [DebugSession(pid=11396, lockfile_path='C:\\\\Users\\\\dariu\\\\AppData\\\\Local\\\\Temp\\\\xauto_session.11396.lock', cmdline=['C:\\\\re\\\\x64dbg_dev\\\\release\\\\x64\\\\x64dbg.exe'], cwd='C:\\\\re\\\\x64dbg_dev\\\\release\\\\x64', window_title='winver.exe - PID: 30944 - Module: ntdll.dll - Thread: Main Thread 20648 - x64dbg', sess_req_rep_port=54561, sess_pub_sub_port=60710), DebugSession(pid=26000, lockfile_path='C:\\\\Users\\\\dariu\\\\AppData\\\\Local\\\\Temp\\\\xauto_session.26000.lock', cmdline=['C:\\\\re\\\\x64dbg_dev\\\\release\\\\x64\\\\x64dbg.exe'], cwd='C:\\\\re\\\\x64dbg_dev\\\\release\\\\x64', window_title='x64dbg', sess_req_rep_port=53337, sess_pub_sub_port=61219)] [+] Terminating the first session [+] Listing running sessions [DebugSession(pid=26000, lockfile_path='C:\\\\Users\\\\dariu\\\\AppData\\\\Local\\\\Temp\\\\xauto_session.26000.lock', cmdline=['C:\\\\re\\\\x64dbg_dev\\\\release\\\\x64\\\\x64dbg.exe'], cwd='C:\\\\re\\\\x64dbg_dev\\\\release\\\\x64', window_title='x64dbg', sess_req_rep_port=53337, sess_pub_sub_port=61219)] [+] Attaching to the second session [+] Detaching from the second session [+] Re-attaching to the second session [+] Terminating the second session API Method Reference start_session(target_exe='', cmdline='', current_dir='') Start a new x64dbg session and optionally load an executable into it. If target_exe is not provided, the debugger starts without any executable. This is useful for performing configuration before the debuggee is loaded. Parameters: Name Type Description Default target_exe str The path to the target executable (optional) '' cmdline str The command line arguments to pass to the executable (optional) '' current_dir str The current working directory to set for the executable (optional) '' Returns: Type Description int The debug session ID Source code in x64dbg_automate\\__init__.py def start_session(self, target_exe: str = \"\", cmdline: str = \"\", current_dir: str = \"\") -> int: \"\"\" Start a new x64dbg session and optionally load an executable into it. If target_exe is not provided, the debugger starts without any executable. This is useful for performing configuration before the debuggee is loaded. Args: target_exe: The path to the target executable (optional) cmdline: The command line arguments to pass to the executable (optional) current_dir: The current working directory to set for the executable (optional) Returns: The debug session ID \"\"\" if len(target_exe.strip()) == 0 and (len(cmdline) > 0 or len(current_dir) > 0): raise ValueError(\"cmdline and current_dir cannot be provided without target_exe\") self.proc = subprocess.Popen([self.x64dbg_path], executable=self.x64dbg_path) self.session_pid = self.proc.pid self.attach_session(self.session_pid) if target_exe.strip() != \"\": self.load_executable(target_exe.strip(), cmdline, current_dir) self.wait_cmd_ready() return self.session_pid attach_session(session_pid) Attach to an existing x64dbg session Parameters: Name Type Description Default session_pid int The session ID to attach to (debugger PID) required Source code in x64dbg_automate\\__init__.py def attach_session(self, session_pid: int) -> None: \"\"\" Attach to an existing x64dbg session Args: session_pid: The session ID to attach to (debugger PID) \"\"\" session = X64DbgClient.wait_for_session(session_pid) self.sess_req_rep_port = session.sess_req_rep_port self.sess_pub_sub_port = session.sess_pub_sub_port self._init_connection() self._assert_connection_compat() detach_session() Detach from the current x64dbg session, leaving the debugger process running. Source code in x64dbg_automate\\__init__.py def detach_session(self) -> None: \"\"\" Detach from the current x64dbg session, leaving the debugger process running. \"\"\" self._close_connection() terminate_session() End the current x64dbg session, terminating the debugger process. Source code in x64dbg_automate\\__init__.py def terminate_session(self) -> None: \"\"\" End the current x64dbg session, terminating the debugger process. \"\"\" sid = self.session_pid self._xauto_terminate_session() self._close_connection() for _ in range(100): time.sleep(0.2) if sid not in [p.pid for p in self.list_sessions()]: return raise TimeoutError(\"Session did not terminate in a reasonable amount of time\") list_sessions() staticmethod Lists all active x64dbg sessions Returns: Type Description list [ DebugSession ] A list of sessions Source code in x64dbg_automate\\__init__.py @staticmethod def list_sessions() -> list[DebugSession]: \"\"\" Lists all active x64dbg sessions Returns: A list of sessions \"\"\" sessions: list[DebugSession] = [] temp_path_cstr = ctypes.create_unicode_buffer(1024) if GetTempPathW(1024, temp_path_cstr) == 0: temp_path = \"c:\\\\windows\\\\temp\\\\\" else: temp_path = temp_path_cstr.value locks = glob.glob(f'{temp_path}xauto_session.*.lock') for lock in locks: while True: try: with open(lock, 'r') as f: sess_req_rep_port = int(f.readline().strip()) sess_pub_sub_port = int(f.readline().strip()) pid = int(lock.split('.')[-2]) if psutil.pid_exists(pid): process = psutil.Process(pid) sessions.append(DebugSession( pid=pid, lockfile_path=lock, cmdline=process.cmdline(), cwd=process.cwd(), window_title=X64DbgClient._window_title_for_pid(pid), sess_req_rep_port=sess_req_rep_port, sess_pub_sub_port=sess_pub_sub_port )) break else: if time.time() - os.path.getctime(lock) > 10.0: logger.warning(f\"Stale lockfile {lock}, removing\") os.unlink(lock) break except FileNotFoundError: # The process exited between the glob and the open break return sessions wait_for_session(session_pid, timeout=10) staticmethod Wait for an x64dbg session to start Parameters: Name Type Description Default session_pid int The session ID to wait for (debugger PID) required timeout int The maximum time to wait in seconds 10 Returns: Type Description DebugSession The awaited debug session object Source code in x64dbg_automate\\__init__.py @staticmethod def wait_for_session(session_pid: int, timeout: int = 10) -> DebugSession: \"\"\" Wait for an x64dbg session to start Args: session_pid: The session ID to wait for (debugger PID) timeout: The maximum time to wait in seconds Returns: The awaited debug session object \"\"\" while timeout > 0: sessions = X64DbgClient.list_sessions() sessions = [s for s in sessions if s.pid == session_pid] if session_pid in [s.pid for s in sessions]: return sessions[0] time.sleep(0.2) timeout -= 0.2 raise TimeoutError(\"Session did not appear in a reasonable amount of time\") API Model Reference DebugSession Represents a debug session in x64dbg Automate Source code in x64dbg_automate\\models.py class DebugSession(BaseModel): \"\"\" Represents a debug session in x64dbg Automate \"\"\" pid: int # The process ID of the debugger lockfile_path: str # The path to the lockfile for the session cmdline: list[str] # The command line arguments used to start the session cwd: str # The current working directory of the session window_title: str # The title of the x64dbg window sess_req_rep_port: int # The port used for zmq request/reply communication sess_pub_sub_port: int # The port used for zmq publish/subscribe communication","title":"Session Control"},{"location":"api/session-control/#session-control","text":"","title":"Session Control"},{"location":"api/session-control/#what-are-sessions","text":"A session refers to an automation-enabled running instance of x64dbg. Each instance of the debugger you launch or attach to has a session ID allocated to it. The automation client relies on sessions to know which debugger instance to communicate with. For all intents and purposes the session ID is equivalent to the debugger PID. After launching x64dbg with the plugin installed its session ID and port binds can be seen in the startup log: [x64dbg-automate] Allocated session ID: 12584 [x64dbg-automate] Allocated PUB/SUB port: 49759 [x64dbg-automate] Allocated REQ/REP port: 52085 Sessions can also be discovered programmatically - with PIDs, command lines, working directories, and window titles provided for disambiguation.","title":"What are Sessions?"},{"location":"api/session-control/#example-sessions","text":"\"\"\" Example: Session Control (32/64 bit) \"\"\" import subprocess import sys from x64dbg_automate import X64DbgClient if len(sys.argv) != 2: print(\"Usage: python sessions.py <x64dbg_path>\") quit(1) print('[+] Creating an x64dbg Automate session using start_session') client1 = X64DbgClient(x64dbg_path=sys.argv[1]) client1.start_session(r'c:\\Windows\\system32\\winver.exe') print('[+] Starting an unconnected session using subprocess.Popen') client2 = X64DbgClient(x64dbg_path=sys.argv[1]) proc = subprocess.Popen([sys.argv[1]], executable=sys.argv[1]) print('[+] Waiting for the unconnected session to start') X64DbgClient.wait_for_session(proc.pid) print('[+] Listing running sessions') sessions = X64DbgClient.list_sessions() print(sessions) print('[+] Terminating the first session') client1.terminate_session() print('[+] Listing running sessions') sessions = X64DbgClient.list_sessions() print(sessions) print('[+] Attaching to the second session') client2.attach_session(sessions[0].pid) print('[+] Detaching from the second session') client2.detach_session() print('[+] Re-attaching to the second session') client2.attach_session(sessions[0].pid) print('[+] Terminating the second session') client2.terminate_session() [+] Creating an x64dbg Automate session using start_session [+] Starting an unconnected session using subprocess.Popen [+] Waiting for the unconnected session to start [+] Listing running sessions [DebugSession(pid=11396, lockfile_path='C:\\\\Users\\\\dariu\\\\AppData\\\\Local\\\\Temp\\\\xauto_session.11396.lock', cmdline=['C:\\\\re\\\\x64dbg_dev\\\\release\\\\x64\\\\x64dbg.exe'], cwd='C:\\\\re\\\\x64dbg_dev\\\\release\\\\x64', window_title='winver.exe - PID: 30944 - Module: ntdll.dll - Thread: Main Thread 20648 - x64dbg', sess_req_rep_port=54561, sess_pub_sub_port=60710), DebugSession(pid=26000, lockfile_path='C:\\\\Users\\\\dariu\\\\AppData\\\\Local\\\\Temp\\\\xauto_session.26000.lock', cmdline=['C:\\\\re\\\\x64dbg_dev\\\\release\\\\x64\\\\x64dbg.exe'], cwd='C:\\\\re\\\\x64dbg_dev\\\\release\\\\x64', window_title='x64dbg', sess_req_rep_port=53337, sess_pub_sub_port=61219)] [+] Terminating the first session [+] Listing running sessions [DebugSession(pid=26000, lockfile_path='C:\\\\Users\\\\dariu\\\\AppData\\\\Local\\\\Temp\\\\xauto_session.26000.lock', cmdline=['C:\\\\re\\\\x64dbg_dev\\\\release\\\\x64\\\\x64dbg.exe'], cwd='C:\\\\re\\\\x64dbg_dev\\\\release\\\\x64', window_title='x64dbg', sess_req_rep_port=53337, sess_pub_sub_port=61219)] [+] Attaching to the second session [+] Detaching from the second session [+] Re-attaching to the second session [+] Terminating the second session","title":"Example: Sessions"},{"location":"api/session-control/#api-method-reference","text":"","title":"API Method Reference"},{"location":"api/session-control/#x64dbg_automate.X64DbgClient.start_session","text":"Start a new x64dbg session and optionally load an executable into it. If target_exe is not provided, the debugger starts without any executable. This is useful for performing configuration before the debuggee is loaded. Parameters: Name Type Description Default target_exe str The path to the target executable (optional) '' cmdline str The command line arguments to pass to the executable (optional) '' current_dir str The current working directory to set for the executable (optional) '' Returns: Type Description int The debug session ID Source code in x64dbg_automate\\__init__.py def start_session(self, target_exe: str = \"\", cmdline: str = \"\", current_dir: str = \"\") -> int: \"\"\" Start a new x64dbg session and optionally load an executable into it. If target_exe is not provided, the debugger starts without any executable. This is useful for performing configuration before the debuggee is loaded. Args: target_exe: The path to the target executable (optional) cmdline: The command line arguments to pass to the executable (optional) current_dir: The current working directory to set for the executable (optional) Returns: The debug session ID \"\"\" if len(target_exe.strip()) == 0 and (len(cmdline) > 0 or len(current_dir) > 0): raise ValueError(\"cmdline and current_dir cannot be provided without target_exe\") self.proc = subprocess.Popen([self.x64dbg_path], executable=self.x64dbg_path) self.session_pid = self.proc.pid self.attach_session(self.session_pid) if target_exe.strip() != \"\": self.load_executable(target_exe.strip(), cmdline, current_dir) self.wait_cmd_ready() return self.session_pid","title":"start_session"},{"location":"api/session-control/#x64dbg_automate.X64DbgClient.attach_session","text":"Attach to an existing x64dbg session Parameters: Name Type Description Default session_pid int The session ID to attach to (debugger PID) required Source code in x64dbg_automate\\__init__.py def attach_session(self, session_pid: int) -> None: \"\"\" Attach to an existing x64dbg session Args: session_pid: The session ID to attach to (debugger PID) \"\"\" session = X64DbgClient.wait_for_session(session_pid) self.sess_req_rep_port = session.sess_req_rep_port self.sess_pub_sub_port = session.sess_pub_sub_port self._init_connection() self._assert_connection_compat()","title":"attach_session"},{"location":"api/session-control/#x64dbg_automate.X64DbgClient.detach_session","text":"Detach from the current x64dbg session, leaving the debugger process running. Source code in x64dbg_automate\\__init__.py def detach_session(self) -> None: \"\"\" Detach from the current x64dbg session, leaving the debugger process running. \"\"\" self._close_connection()","title":"detach_session"},{"location":"api/session-control/#x64dbg_automate.X64DbgClient.terminate_session","text":"End the current x64dbg session, terminating the debugger process. Source code in x64dbg_automate\\__init__.py def terminate_session(self) -> None: \"\"\" End the current x64dbg session, terminating the debugger process. \"\"\" sid = self.session_pid self._xauto_terminate_session() self._close_connection() for _ in range(100): time.sleep(0.2) if sid not in [p.pid for p in self.list_sessions()]: return raise TimeoutError(\"Session did not terminate in a reasonable amount of time\")","title":"terminate_session"},{"location":"api/session-control/#x64dbg_automate.X64DbgClient.list_sessions","text":"Lists all active x64dbg sessions Returns: Type Description list [ DebugSession ] A list of sessions Source code in x64dbg_automate\\__init__.py @staticmethod def list_sessions() -> list[DebugSession]: \"\"\" Lists all active x64dbg sessions Returns: A list of sessions \"\"\" sessions: list[DebugSession] = [] temp_path_cstr = ctypes.create_unicode_buffer(1024) if GetTempPathW(1024, temp_path_cstr) == 0: temp_path = \"c:\\\\windows\\\\temp\\\\\" else: temp_path = temp_path_cstr.value locks = glob.glob(f'{temp_path}xauto_session.*.lock') for lock in locks: while True: try: with open(lock, 'r') as f: sess_req_rep_port = int(f.readline().strip()) sess_pub_sub_port = int(f.readline().strip()) pid = int(lock.split('.')[-2]) if psutil.pid_exists(pid): process = psutil.Process(pid) sessions.append(DebugSession( pid=pid, lockfile_path=lock, cmdline=process.cmdline(), cwd=process.cwd(), window_title=X64DbgClient._window_title_for_pid(pid), sess_req_rep_port=sess_req_rep_port, sess_pub_sub_port=sess_pub_sub_port )) break else: if time.time() - os.path.getctime(lock) > 10.0: logger.warning(f\"Stale lockfile {lock}, removing\") os.unlink(lock) break except FileNotFoundError: # The process exited between the glob and the open break return sessions","title":"list_sessions"},{"location":"api/session-control/#x64dbg_automate.X64DbgClient.wait_for_session","text":"Wait for an x64dbg session to start Parameters: Name Type Description Default session_pid int The session ID to wait for (debugger PID) required timeout int The maximum time to wait in seconds 10 Returns: Type Description DebugSession The awaited debug session object Source code in x64dbg_automate\\__init__.py @staticmethod def wait_for_session(session_pid: int, timeout: int = 10) -> DebugSession: \"\"\" Wait for an x64dbg session to start Args: session_pid: The session ID to wait for (debugger PID) timeout: The maximum time to wait in seconds Returns: The awaited debug session object \"\"\" while timeout > 0: sessions = X64DbgClient.list_sessions() sessions = [s for s in sessions if s.pid == session_pid] if session_pid in [s.pid for s in sessions]: return sessions[0] time.sleep(0.2) timeout -= 0.2 raise TimeoutError(\"Session did not appear in a reasonable amount of time\")","title":"wait_for_session"},{"location":"api/session-control/#api-model-reference","text":"","title":"API Model Reference"},{"location":"api/session-control/#x64dbg_automate.models.DebugSession","text":"Represents a debug session in x64dbg Automate Source code in x64dbg_automate\\models.py class DebugSession(BaseModel): \"\"\" Represents a debug session in x64dbg Automate \"\"\" pid: int # The process ID of the debugger lockfile_path: str # The path to the lockfile for the session cmdline: list[str] # The command line arguments used to start the session cwd: str # The current working directory of the session window_title: str # The title of the x64dbg window sess_req_rep_port: int # The port used for zmq request/reply communication sess_pub_sub_port: int # The port used for zmq publish/subscribe communication","title":"DebugSession"},{"location":"api/settings/","text":"Settings Debugger settings can be controlled at runtime. Setting up consistent defaults may be important for scripts to run reproducibly. API Method Reference get_setting_str(section, setting_name) Retrieves a string setting from the x64dbg configuration Parameters: Name Type Description Default section str The section of the setting required setting_name str The name of the setting required Returns: Type Description str | None The value of the setting or None if the setting was not found Source code in x64dbg_automate\\commands_xauto.py def get_setting_str(self, section: str, setting_name: str) -> str | None: \"\"\" Retrieves a string setting from the x64dbg configuration Args: section: The section of the setting setting_name: The name of the setting Returns: The value of the setting or None if the setting was not found \"\"\" res, setting = self._send_request(XAutoCommand.XAUTO_REQ_DBG_READ_SETTING_SZ, section, setting_name) if not res: return None return setting get_setting_int(section, setting_name) Retrieves a numeric setting from the x64dbg configuration Parameters: Name Type Description Default section str The section of the setting required setting_name str The name of the setting required Returns: Type Description int | None The value of the setting or None if the setting was not found Source code in x64dbg_automate\\commands_xauto.py def get_setting_int(self, section: str, setting_name: str) -> int | None: \"\"\" Retrieves a numeric setting from the x64dbg configuration Args: section: The section of the setting setting_name: The name of the setting Returns: The value of the setting or None if the setting was not found \"\"\" res, setting = self._send_request(XAutoCommand.XAUTO_REQ_DBG_READ_SETTING_UINT, section, setting_name) if not res: return None return setting set_setting_str(section, setting_name, setting_val) Sets a string setting in the x64dbg configuration Parameters: Name Type Description Default section str The section of the setting required setting_name str The name of the setting required setting_val str The desired value of the setting required Returns: Type Description bool Success Source code in x64dbg_automate\\commands_xauto.py def set_setting_str(self, section: str, setting_name: str, setting_val: str) -> bool: \"\"\" Sets a string setting in the x64dbg configuration Args: section: The section of the setting setting_name: The name of the setting setting_val: The desired value of the setting Returns: Success \"\"\" return self._send_request(XAutoCommand.XAUTO_REQ_DBG_WRITE_SETTING_SZ, section, setting_name, setting_val) set_setting_int(section, setting_name, setting_val) Sets a numeric setting in the x64dbg configuration Parameters: Name Type Description Default section str The section of the setting required setting_name str The name of the setting required setting_val int The desired value of the setting required Returns: Type Description bool Success Source code in x64dbg_automate\\commands_xauto.py def set_setting_int(self, section: str, setting_name: str, setting_val: int) -> bool: \"\"\" Sets a numeric setting in the x64dbg configuration Args: section: The section of the setting setting_name: The name of the setting setting_val: The desired value of the setting Returns: Success \"\"\" return self._send_request(XAutoCommand.XAUTO_REQ_DBG_WRITE_SETTING_UINT, section, setting_name, setting_val)","title":"Settings"},{"location":"api/settings/#settings","text":"Debugger settings can be controlled at runtime. Setting up consistent defaults may be important for scripts to run reproducibly.","title":"Settings"},{"location":"api/settings/#api-method-reference","text":"","title":"API Method Reference"},{"location":"api/settings/#x64dbg_automate.X64DbgClient.get_setting_str","text":"Retrieves a string setting from the x64dbg configuration Parameters: Name Type Description Default section str The section of the setting required setting_name str The name of the setting required Returns: Type Description str | None The value of the setting or None if the setting was not found Source code in x64dbg_automate\\commands_xauto.py def get_setting_str(self, section: str, setting_name: str) -> str | None: \"\"\" Retrieves a string setting from the x64dbg configuration Args: section: The section of the setting setting_name: The name of the setting Returns: The value of the setting or None if the setting was not found \"\"\" res, setting = self._send_request(XAutoCommand.XAUTO_REQ_DBG_READ_SETTING_SZ, section, setting_name) if not res: return None return setting","title":"get_setting_str"},{"location":"api/settings/#x64dbg_automate.X64DbgClient.get_setting_int","text":"Retrieves a numeric setting from the x64dbg configuration Parameters: Name Type Description Default section str The section of the setting required setting_name str The name of the setting required Returns: Type Description int | None The value of the setting or None if the setting was not found Source code in x64dbg_automate\\commands_xauto.py def get_setting_int(self, section: str, setting_name: str) -> int | None: \"\"\" Retrieves a numeric setting from the x64dbg configuration Args: section: The section of the setting setting_name: The name of the setting Returns: The value of the setting or None if the setting was not found \"\"\" res, setting = self._send_request(XAutoCommand.XAUTO_REQ_DBG_READ_SETTING_UINT, section, setting_name) if not res: return None return setting","title":"get_setting_int"},{"location":"api/settings/#x64dbg_automate.X64DbgClient.set_setting_str","text":"Sets a string setting in the x64dbg configuration Parameters: Name Type Description Default section str The section of the setting required setting_name str The name of the setting required setting_val str The desired value of the setting required Returns: Type Description bool Success Source code in x64dbg_automate\\commands_xauto.py def set_setting_str(self, section: str, setting_name: str, setting_val: str) -> bool: \"\"\" Sets a string setting in the x64dbg configuration Args: section: The section of the setting setting_name: The name of the setting setting_val: The desired value of the setting Returns: Success \"\"\" return self._send_request(XAutoCommand.XAUTO_REQ_DBG_WRITE_SETTING_SZ, section, setting_name, setting_val)","title":"set_setting_str"},{"location":"api/settings/#x64dbg_automate.X64DbgClient.set_setting_int","text":"Sets a numeric setting in the x64dbg configuration Parameters: Name Type Description Default section str The section of the setting required setting_name str The name of the setting required setting_val int The desired value of the setting required Returns: Type Description bool Success Source code in x64dbg_automate\\commands_xauto.py def set_setting_int(self, section: str, setting_name: str, setting_val: int) -> bool: \"\"\" Sets a numeric setting in the x64dbg configuration Args: section: The section of the setting setting_name: The name of the setting setting_val: The desired value of the setting Returns: Success \"\"\" return self._send_request(XAutoCommand.XAUTO_REQ_DBG_WRITE_SETTING_UINT, section, setting_name, setting_val)","title":"set_setting_int"}]}